schema {
  query: Query
  mutation: Mutation
}

"Autogenerated return type of AcceptModerationFixMutation."
type AcceptModerationFixMutationPayload {
  "Return the moderation fix"
  moderationFix: ModerationFix!
  "Returns true if the fix was accepted successfully"
  success: Boolean!
}

"An entry from the log of actions taken by a user"
type ActionLog {
  "The type of action being performed"
  actionId: ActionType!
  "True if the logged object contains adult content"
  adultContent: Boolean
  "Date the action took place (Unix timestamp)"
  date: Int!
  "Description of the action"
  description: String
  "The game associated with this action"
  gameId: Int!
  "The database ID for this actionLog."
  id: Int!
  "IP address associated with the action"
  ip: String
  "The id of the object affected by this action"
  objectId: Int!
  "Name of the object affected by this action"
  objectName: String
  "The type of object affected by this action"
  objectType: ObjectType!
  "URL of the object affected by this action"
  objectUrl: String
  "The id of a related object in this action (e.g. a file or image related to a mod"
  relatedId: Int
  "Name of the related object"
  relatedName: String
  "The related object's type"
  relatedType: ObjectType
  "URL of the related object"
  relatedUrl: String
  "URL of the thumbnail for the object affected by this action"
  thumbnailUrl: String
  "The user who took this action"
  userId: Int!
}

"The connection type for ActionLog."
type ActionLogConnection {
  "A list of edges."
  edges: [ActionLogEdge]
  "A list of nodes."
  nodes: [ActionLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type ActionLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ActionLog
}

"Types of action which can be performed on an object in an action log"
enum ActionType {
  UNDEFINED_ENTRY
  CREATED
  LINKED
  NEWVERSION
  ATTRIBUTE_CHANGED
  PERMISSION_CHANGED
  REMOVED
  VERIFIED
  DELETED
  PRIMARY_IMAGE_CHANGED
  IMAGE_VERIFIED
  ADDED
  ENDORSED
  EDITED
  WASTEBIN
  CREATED_UNPUBLISHED
  ABSTAINED
  TRACK
  UNTRACK
  BLOCK
  UNBLOCK
  USERNAME_CHANGED
}

"Autogenerated return type of AddFavouriteGameMutation."
type AddFavouriteGameMutationPayload {
  "True if the favourite was successfully created"
  success: Boolean!
}

"Autogenerated return type of AddHeaderImageToCollectionMutation."
type AddHeaderImageToCollectionMutationPayload {
  "Header image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddImageToCollectionMutation."
type AddImageToCollectionMutationPayload {
  "Image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddTagToCollectionMutation."
type AddTagToCollectionMutationPayload {
  "True if all tags were added to the collection"
  success: Boolean!
}

"Autogenerated return type of AddTileImageToCollectionMutation."
type AddTileImageToCollectionMutationPayload {
  "Tile image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddVideoToCollectionMutation."
type AddVideoToCollectionMutationPayload {
  "Video that was added to the collection"
  video: CollectionVideo!
}

"Autogenerated return type of AmendModerationMutation."
type AmendModerationMutationPayload {
  "Return Types::ModerationType"
  moderation: Moderation!
  "Boolean determining success or failure of the request."
  success: Boolean!
}

"Something that can have files attached to it"
interface Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
}

"Type that exposes the attachment urls"
type Attachment implements Node {
  "The attachment filename"
  filename: String!
  "A unique ID for this attachment. This is a signed ID that will change between requests. This\nis expected behaviour and is to avoid tampering."
  id: ID!
  "The attachment URL"
  url: String!
}

"Average rating for a single revision and total number of votes"
type AverageRating {
  "Average rating for this revision"
  average: Float!
  "Number of positive votes"
  positive: Int!
  "Total number of votes"
  total: Int!
}

input BaseFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

input BaseSortValue {
  "Direction of sort."
  direction: SortDirection!
}

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"A boolean value E.g. true or false"
input BooleanFilterValue {
  "Boolean Value"
  value: Boolean!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Acceptable bug report closure reasons"
enum BugReportClosureReason {
  "None"
  none
  "Resolved"
  resolved
  "Not a bug"
  not_a_bug
  "Wont fix"
  wont_fix
}

"Moderation Status of a Bug Report"
enum BugReportModerationStatus {
  "None"
  none
  "Hidden"
  hidden
}

"Acceptable bug report statuses"
enum BugReportStatus {
  "Open"
  open
  "Closed"
  closed
}

"A category into which related entities may fall"
type Category {
  "Whether the category has been approved"
  approved: Boolean!
  "The id of the user who approved the category"
  approvedBy: Int
  "A list of games for which this category is used"
  categoryGames: [Game!]
  "Time of when this category was first created."
  createdAt: DateTime!
  "A brief description of the category's purpose"
  description: String!
  "Time of when this category was discarded."
  discardedAt: DateTime
  "The database ID for this category."
  id: Int!
  "The name of the category"
  name: String!
  "The id of the parent category"
  parentId: Int!
  "The id of the user who suggested the category"
  suggestedBy: Int!
  "Time of when this category was last updated."
  updatedAt: DateTime!
}

"Autogenerated return type of ChangeCollectionOwner."
type ChangeCollectionOwnerPayload {
  "Updated collection"
  collection: Collection!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of ClearCollectionBugReportModerationStatusMutation."
type ClearCollectionBugReportModerationStatusMutationPayload {
  "Collection bug report whose status was cleared"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of ClearCommentModerationStatusMutation."
type ClearCommentModerationStatusMutationPayload {
  "The comment that had its moderation status cleared."
  comment: Comment!
}

"Autogenerated return type of ClearThreadModerationStatusMutation."
type ClearThreadModerationStatusMutationPayload {
  "The comment thread that had its moderation status cleared."
  commentThread: CommentThread!
}

"Autogenerated return type of CloseCollectionBugReportMutation."
type CloseCollectionBugReportMutationPayload {
  "Collection bug report which was closed"
  collectionBugReport: CollectionBugReport!
}

"A curated collection of mods"
type Collection {
  "Indicates whether the collection contains adult content"
  adultContent: Boolean @deprecated(reason: "Adult content is now indicated at the revision level")
  "Whether to allow non-curator users to upload media"
  allowUserMedia: Boolean
  "Fetch a bug report for this collection by its id"
  bugReport("The database ID for this bug report." bugReportId: ID!): CollectionBugReport!
  "A list of bug reports raised for the collection"
  bugReports("Filter bug reports by status. Possible opens are \"Open\" or \"Closed\"" status: BugReportStatus! "Column for sorting bug reports" sortBy: String "Direction for sorting bug reports" sortDirection: String "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CollectionBugReportConnection!
  "A category into which related entities may fall"
  category: Category
  "A list of changelogs created for the revisions of this collection"
  collectionChangelogs: [CollectionChangelog!]
  "Available collection statuses"
  collectionStatus: CollectionStatus
  "A link to the forum thread containing comments"
  commentLink: String
  "The comment thread for this collection."
  commentThread: CommentThread!
  "Time of when this collection was first created."
  createdAt: DateTime!
  "Latest published revision"
  currentRevision("Revision number" revision: Int): CollectionRevision! @deprecated(reason: "Deprecated in favour of using a 'collectionRevision' query")
  "A description of the collection in Markdown format"
  description: String!
  "A reason why the collection was discarded"
  discardReason: CollectionDiscardReason
  "Time of when this collection was discarded."
  discardedAt: DateTime
  "A link to download the collection"
  downloadLink: String!
  "If there is a draft revision in this collection, this will return the revisionNumber\nfor that revision. If there are no draft revisions, this will simply be null"
  draftRevisionNumber: Int
  "The number of endorsements given to the collection"
  endorsements: Int!
  "Time of when the first of this collection's revisions\nwas first published"
  firstPublishedAt: DateTime
  "The forum topic created to hold comments for this collection"
  forumTopic: ForumTopic @deprecated(reason: "Use `commentThread` instead.")
  "The game for which the collection was created"
  game: Game!
  "The id of the game for which the collection was created"
  gameId: Int!
  "The image used as the background of the header on the collection's page"
  headerImage: CollectionImage
  "The database ID for this collection."
  id: Int!
  "Time of when one of this collection's revisions\nwas last published"
  lastPublishedAt: DateTime
  "The latest published revision for this collection. This will be\nnull for collections with no published revisions"
  latestPublishedRevision: CollectionRevision
  "Rating of the latest published revision"
  latestPublishedRevisionRating: String
  "Time of when this collection was first listed"
  listedAt: DateTime
  "Whether uploaded media requires verification before being displayed"
  manuallyVerifyMedia: Boolean
  "A list of media uploaded to the collection, including images and videos"
  media: [CollectionMediaUnion!]!
  "Metadata information about a collection"
  metadata: CollectionMetadata
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "A list of moderation actions taken against this collection"
  moderations: [Moderation!]
  "The collection name"
  name: String!
  "An average taken from all revision ratings"
  overallRating: String
  "Total number of ratings given across all revisions"
  overallRatingCount: Int
  "The list of permissions granted to the requesting user against this collection."
  permissions: [Permission!]
  "Returns \"sanitized\" collection revisions. Safe to use with discarded revisions."
  publicRevisions: [PublicCollectionRevision!]
  "Time of when one of this collection's revisions\nwas last published"
  publishedAt: DateTime @deprecated(reason: "Use `last_published_at` instead.")
  "A 30 day average of all revision ratings"
  recentRating: String
  "Total number of ratings given in the last 30 days"
  recentRatingCount: Int
  "A list of revisions for the collection"
  revisions: [CollectionRevision!]!
  "A random string of characters identifying the collection. This is the identifier used in\na collection page url."
  slug: String!
  "A brief summary of the collection"
  summary: String!
  "A list of tags attached to the collection, used to surface the collection in search results"
  tags: [Tag!]!
  "The image used to identify the collection in list views"
  tileImage: CollectionImage
  "The total number of times this collection has been downloaded"
  totalDownloads: Int!
  "The total number of unique users who have downloaded this collection"
  uniqueDownloads: Int!
  "Time of when this collection was last updated."
  updatedAt: DateTime!
  "The curating user"
  user: User!
  "The id of the collection curator"
  userId: Int!
}

"Enum for the aggregated collection values."
enum CollectionAggregate {
  adult_content
  categories
  collection_ratings
  collection_statuses
  games
  games_and_game_versions
  game_versions
  has_draft_revision
  has_published_revision
  tags
  general_search
}

"A collection bug report."
type CollectionBugReport implements Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
  "Date that this report was changed to closed"
  closedAt: DateTime
  "If closed, what was the reason for closing the report"
  closureReason: BugReportClosureReason
  "A curated collection of mods"
  collection: Collection!
  "The collection revision number."
  collectionRevisionNumber: Int!
  "The comment thread for this collection bug report."
  commentThread: CommentThread!
  "Date that this report was created"
  createdAt: DateTime!
  "User-provided summary of the Bug Report"
  description: String
  "User that hid this Bug Report from public view"
  hiddenBy: User
  "If hidden, this will provide a reason. This is\nintended for moderators, admins and collection curators"
  hiddenInternalReason: String
  "If hidden, this will provide the reason"
  hiddenReason: String
  "The database ID for this collection bug report."
  id: ID!
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "If under moderation, can be none or hidden"
  moderationStatus: BugReportModerationStatus!
  "Date that this report was changed to open"
  openedAt: DateTime
  "Provides a list of all permissions for this\nreport, using the context of the current user"
  permissions: [Permission!]
  "User that reported this Bug Report"
  reporter: User!
  "Status, can be Open or Closed"
  status: BugReportStatus!
  "Title of the bug report"
  title: String!
  "Date that this report was last updated"
  updatedAt: DateTime!
}

"The connection type for CollectionBugReport."
type CollectionBugReportConnection {
  "A list of edges."
  edges: [CollectionBugReportEdge]
  "A list of nodes."
  nodes: [CollectionBugReport]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type CollectionBugReportEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CollectionBugReport
}

"A changelog attached to a collection revision"
type CollectionChangelog {
  "The id of the collection revision for which this changelog was created"
  collectionRevisionId: Int!
  "Time of when this collection changelog was first created."
  createdAt: DateTime!
  "The content of the collection changelog, in Markdown format"
  description: String!
  "The database ID for this collection changelog."
  id: Int!
  "The revision number of the collection revision for which this changelog was created"
  revisionNumber: Int!
  "Time of when this collection changelog was last updated."
  updatedAt: DateTime!
}

"A reason for which a revision has been retracted."
type CollectionDiscardReason {
  "The id of the collection which was discarded"
  collectionId: Int!
  "Time of when this collection discard reason was first created."
  createdAt: DateTime!
  "The database ID for this collection discard reason."
  id: Int!
  "The reason why the collection was discarded"
  reason: String!
  "Time of when this collection discard reason was last updated."
  updatedAt: DateTime!
}

input CollectionGeneralSearchFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Images related to a collection"
type CollectionImage implements GloballyIdentifiable & Reorderable {
  "The alt text describing the image for screen readers"
  altText: String
  "The collection for which the image was uploaded"
  collection: Collection!
  "Time of when this collection image was first created."
  createdAt: DateTime!
  "Time of when this collection image was discarded."
  discardedAt: DateTime
  "The global ID for this entity."
  globalId: ID
  "The database ID for this collection image."
  id: ID!
  "Determines where the image is displayed"
  imageType: ImageTypes!
  "The order of this entity in the list."
  order: String!
  "The collection revision for which the image was uploaded"
  revision: CollectionRevision
  "Can be used to select a scaled down\/compressed version of the image"
  thumbnailUrl("The thumbnail size" size: ThumbnailSize!): String!
  "The image title"
  title: String
  "Time of when this collection image was last updated."
  updatedAt: DateTime!
  "The image resource url"
  url: String!
  "The user who uploaded the image"
  user: User!
}

"The JSON manifest that defines a collection"
input CollectionManifest {
  "Manifest information"
  info: CollectionManifestInfo!
  "List of mod resources for the manifest"
  mods: [CollectionManifestMod!]!
}

"The info section of the JSON manifest"
input CollectionManifestInfo {
  "The collection author's name"
  author: String!
  "The url of the author's profile"
  authorUrl: String
  "The name of the collection"
  name: String!
  "A description of the collection"
  description: String
  "A short summary of the collection"
  summary: String
  "The domain name of the game"
  domainName: String!
  "A list of game versions that this revision has been tested with"
  gameVersions: [String!]
}

"Defines a mod to be used in a collection as part of the manifest"
input CollectionManifestMod {
  "The name of the mod"
  name: String!
  "The mod version"
  version: String!
  "Whether the mod is required for this collection"
  optional: Boolean!
  "The domain name of the game for the mod"
  domainName: String!
  "Mod source details"
  source: CollectionManifestModSource!
  "The name of the mod author"
  author: String
}

"Source information for a mod (nexus or other) as part of the manifest"
input CollectionManifestModSource {
  "Type of the mod source"
  type: ModSource!
  "Mod id"
  modId: Int
  "File ID"
  fileId: Int
  "An MD5 hash of the file for verification"
  md5: String
  "The file size in kb"
  fileSize: Int
  "Update policy type"
  updatePolicy: UpdatePolicy
  "Logical file name of the mod resource"
  logicalFilename: String
  "File expression of the mod resource"
  fileExpression: String
  "The direct url of the file"
  url: String
  "Does the mod includes adult content"
  adultContent: Boolean
}

"Collection Media"
union CollectionMediaUnion = CollectionImage | CollectionVideo

"Metadata information about a collection"
type CollectionMetadata {
  "A timestamp indicating the first time the user downloaded this collection"
  downloadedAt: DateTime
  "A positive value indicates an endorsement by the user, while a negative value\nindicates abstention (will be null if the user has not endorsed the collection)"
  endorsementValue: Int
  "The latest revision number downloaded by the user for this collection"
  latestDownloadedRevisionNumber: Int
}

type CollectionPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Nodes for pagination"
  nodes: [Collection!]!
  "Aggregations available, if supported for this query and requested."
  nodesAggregations: [NodesAggregation!]
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"The data payload used to create a collection revision"
input CollectionPayload {
  "Whether the collection includes adult content"
  adultContent: Boolean!
  "Collection manifest"
  collectionManifest: CollectionManifest!
  "Collection schema ID (Default: 1)"
  collectionSchemaId: Int!
}

"An immutable revision of a collection"
type CollectionRevision {
  "If true, this revision could contain adult content and needs to be treated accordingly"
  adultContent: Boolean!
  "The size of bundled assets within the revision in bytes"
  assetsSizeBytes: BigInt!
  "Gets the collection that this revision belongs to. This will ignore adult_content flags."
  collection: Collection!
  "A changelog attached to a collection revision"
  collectionChangelog: CollectionChangelog
  "The database ID for this collection."
  collectionId: Int!
  "A model of the expected structure for a collection manifest"
  collectionSchema: CollectionSchema!
  "The database ID for this collection schema."
  collectionSchemaId: Int!
  "The link to generate a content preview for the revision"
  contentPreviewLink: String!
  "Time of when this revision was first created."
  createdAt: DateTime!
  "Time of when this revision was discarded."
  discardedAt: DateTime
  "The download link for the revision"
  downloadLink: String!
  "Array of external resources referenced by this revision"
  externalResources: [ExternalResource!]!
  "The total size of the revision in bytes"
  fileSize: BigInt! @deprecated(reason: "Use \"totalSize\" instead.")
  "A list of game versions for which the revision has been confirmed to work (usually the\ngame version for which the revision was created)"
  gameVersions: [GameVersion!]
  "The database ID for this revision."
  id: Int!
  "Additional information about the installation process of this revision"
  installationInfo: String
  "Will be true if the revision is the latest published for the collection"
  latest: Boolean!
  "Metadata information about a collection revision"
  metadata: CollectionRevisionMetadata
  "List of authors of the mods included in this revision ordered (DESC) by the number of\nmods in the revision."
  modAuthors("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): UserConnection!
  "The number of mods and external resources in this collection"
  modCount: Int!
  "A list of mod files included in the revision"
  modFiles: [CollectionRevisionMod!]!
  "An average taken from all ratings for this revision"
  overallRating: String
  "A count of all ratings for this revision"
  overallRatingCount: Int
  "Average rating for a single revision and total number of votes"
  rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
  "A reason for which a revision has been retracted."
  retractionReason: RetractionReason
  "The revision number"
  revision: Int! @deprecated(reason: "Use \"revisionNumber\" instead.")
  "The revision number"
  revisionNumber: Int!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  revisionStatus: String!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  status: String!
  "The total number of times the revision has been downloaded"
  totalDownloads: Int!
  "The total size of the revision in bytes"
  totalSize: BigInt!
  "The number of unique users who have download the revision"
  uniqueDownloads: Int!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"Metadata information about a collection revision"
type CollectionRevisionMetadata {
  "A timestamp indicating the first time the user downloaded this revision"
  downloadedAt: DateTime
  "Indicates the rating given by the user to a revision"
  ratingValue: RatingOptions
}

"A mod file included in a collection"
type CollectionRevisionMod {
  "The id of the collection revision including the mod file"
  collectionRevisionId: Int!
  "The mod file"
  file: ModFile
  "The mod file's id"
  fileId: Int!
  "The game id for the mod file"
  gameId: Int!
  "The database ID for this collection revision mod."
  id: ID!
  "Whether the mod file is required for the collection"
  optional: Boolean!
  "Indicates to mod managers how they should handle automatic updates"
  updatePolicy: String!
  "The mod file version"
  version: String!
}

"A model of the expected structure for a collection manifest"
type CollectionSchema {
  "Time of when this collection schema was first created."
  createdAt: DateTime!
  "The database ID for this collection schema."
  id: Int!
  "Time of when this collection schema was last updated."
  updatedAt: DateTime!
  "Schema version for the collection manifest format"
  version: String!
}

"Available collection statuses"
enum CollectionStatus {
  "Publicly visible"
  listed
  "Does not appear in lists"
  unlisted
  "Under moderation"
  under_moderation
  "Discarded"
  discarded
}

"Videos related to a collection"
type CollectionVideo implements GloballyIdentifiable & Reorderable {
  "Collection that this video belongs to"
  collection: Collection!
  "Time of when this collection video was first created."
  createdAt: DateTime!
  "Time of when this collection video was discarded."
  discardedAt: DateTime
  "The global ID for this entity."
  globalId: ID
  "The database ID for this collection video."
  id: ID!
  "The order of this entity in the list."
  order: String!
  "Revision that this video belongs to"
  revision: CollectionRevision
  "The thumbnail URL for the video."
  thumbnailUrl: String!
  "The title of the video."
  title: String!
  "Time of when this collection video was last updated."
  updatedAt: DateTime!
  "URL of this video"
  url: String!
  "Uploader of this video"
  user: User!
}

"Facet fields specific to the Collections query. NOTE- you should not (yet) use a nested\naggregation with a facet"
input CollectionsFacet {
  "Facet on collection adult content."
  adultContent: [String!]
  "Facet on collection category."
  categoryName: [String!]
  "Facet on collection ratings."
  collectionRating: [String!]
  "Facet on collection status."
  collectionStatus: [String!]
  "Facet on collection game."
  gameName: [String!]
  "Facet on collection game."
  gameIds: [String!]
  "Facet on collection game versions."
  gameVersion: [String!]
  "Facet on whether collection has a draft revision."
  hasDraftRevision: [String!]
  "Facet on whether collection has at least one published revision."
  hasPublishedRevision: [String!]
  "Facet on collection tags."
  tag: [String!]
}

"Common filter fields specific to the Collections query"
input CollectionsFilter {
  "Nested filters."
  filter: [CollectionsFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Collection Name"
  name: [BaseFilterValue!]
  "Collection Rating"
  collectionRating: [BaseFilterValue!]
  "Status of the collection. Valid values are: \"unlisted\",\n\"under_moderation\" (moderators\/admins only), \"discarded\" (moderators\/admins only)."
  collectionStatus: [BaseFilterValue!]
  "Game ID"
  gameId: [BaseFilterValue!]
  "Game domain name E.g. skyrim"
  gameDomain: [BaseFilterValue!]
  "Game name E.g. Skyrim"
  gameName: [BaseFilterValue!]
  "Category ID"
  categoryId: [BaseFilterValue!]
  "Category name"
  categoryName: [BaseFilterValue!]
  "Filter collections for specific game versions"
  gameVersion: [BaseFilterValue!]
  "The mod unique identifier."
  modUid: [BaseFilterValue!]
  "The mod name, exact match."
  modName: [BaseFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "Whether to show adult content in search results"
  adultContent: [BooleanFilterValue!]
  "Only show collections that have a draft revision"
  hasDraftRevision: [BooleanFilterValue!]
  "Only show collections that have a published revision"
  hasPublishedRevision: [BooleanFilterValue!]
  "Text search on name, summary and description, partial match."
  generalSearch: [CollectionGeneralSearchFilterValue!]
}

"Common filter fields specific to the Collections query"
input CollectionsSearchFilter {
  "Nested filters."
  filter: [CollectionsSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Author ID"
  userId: [BaseFilterValue!]
  "Collection Name"
  name: [BaseFilterValue!]
  "Collection Rating"
  collectionRating: [BaseFilterValue!]
  "Created at date"
  createdAt: [BaseFilterValue!]
  "Updated at date"
  updatedAt: [BaseFilterValue!]
  "Collection Status"
  collectionStatus: [BaseFilterValue!]
  "Game ID"
  gameId: [BaseFilterValue!]
  "Game domain name E.g. skyrim"
  gameDomain: [BaseFilterValue!]
  "Game name E.g. Skyrim"
  gameName: [BaseFilterValue!]
  "Category ID"
  categoryId: [BaseFilterValue!]
  "Category name"
  categoryName: [BaseFilterValue!]
  "Filter collections for specific game versions"
  gameVersion: [BaseFilterValue!]
  "The mod unique identifier."
  modUid: [BaseFilterValue!]
  "The mod name, exact match."
  modName: [BaseFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "Whether to show adult content in search results"
  adultContent: [BooleanFilterValue!]
  "Only show collections that have a draft revision"
  hasDraftRevision: [BooleanFilterValue!]
  "Only show collections that have a published revision"
  hasPublishedRevision: [BooleanFilterValue!]
  "Text search on name, summary and description, partial match."
  generalSearch: [CollectionGeneralSearchFilterValue!]
}

"Sort fields specific to a Collections query."
input CollectionsSearchSort {
  "Filter query relevance, works best with non wildcard queries."
  relevance: BaseSortValue
  "Random collections."
  random: RandomSortValue
  "Created at date"
  createdAt: BaseSortValue
  "Endorsements count"
  endorsements: BaseSortValue
  "Downloads count"
  downloads: BaseSortValue
}

"A comment."
type Comment implements Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
  "The content of the latest revision for this comment."
  body: String!
  "Time of when this comment was first created."
  createdAt: DateTime!
  "The user that created this comment."
  creator: User!
  "The pagination cursor for this comment."
  cursor: String!
  "Time of when this comment was discarded."
  discardedAt: DateTime
  "The user that discarded this comment."
  discardedBy: User
  "Time of when this comment was hidden."
  hiddenAt: DateTime
  "The user that hid this comment."
  hiddenBy: User
  "The internal reason why this comment was hidden. Only accessible to admins and moderators."
  hiddenInternalReason: String
  "The public reason why this comment was hidden."
  hiddenReason: String
  "The database ID for this comment."
  id: ID!
  "Returns a boolean indicating whether this comment is discarded."
  isDiscarded: Boolean!
  "Is this a pinned comment"
  isPinned: Boolean!
  "Comment likes count."
  likesCount: Int!
  "Time of when this comment was locked."
  lockedAt: DateTime
  "The user that locked this comment."
  lockedBy: User
  "Returns a boolean indicating whether this comment was moderated by an admin."
  moderatedByAdmin: Boolean!
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "The moderation status of this comment."
  moderationStatus: CommentModerationStatus!
  "The parent comment."
  parent: Comment
  "The user that pinned this comment."
  pinPriority: Int
  "User which pinned the comment"
  pinnedBy: User
  "Returns a boolean indicating whether this comment was pinned by an admin."
  pinnedByAdmin: Boolean!
  "A list of replies to this comment."
  replies("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentConnection!
  "The revisions of this comment."
  revisions: [CommentRevision!]!
  "Time of when this comment was last updated."
  updatedAt: DateTime!
  "Returns a boolean indicating whether the viewing user has liked this comment."
  viewerHasLiked: Boolean!
}

"The connection type for Comment."
type CommentConnection {
  "A list of edges."
  edges: [CommentEdge]
  "A list of nodes."
  nodes: [Comment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type CommentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Comment
}

"Enum for available moderation states: \"none\", \"hidden\", \"locked\""
enum CommentModerationStatus {
  "The comment is not under moderation."
  none
  "The comment cannot be viewed."
  hidden
  "The comment cannot be interacted with."
  locked
}

"A comment report."
type CommentReport {
  "The comment that this report was created for."
  comment: Comment!
  "Time of when this report was first created."
  createdAt: DateTime!
  "A more detailed reason why this comment was reported."
  description: String!
  "The database ID for this report."
  id: ID!
  "The reason why this comment was reported."
  reason: String!
  "The user that created this report."
  reporter: User!
  "The status of this report."
  status: CommentReportStatus!
  "Time of when this report was last updated."
  updatedAt: DateTime!
}

"Enum for available report states: \"open\", \"resolved\""
enum CommentReportStatus {
  "The report is pending review by a moderator."
  open
  "The report has been reviewed by a moderator."
  resolved
}

"A comment revision."
type CommentRevision implements Node {
  "The content of this revision."
  body: String!
  "Time of when this revision was first created."
  createdAt: DateTime!
  "ID of the object."
  id: ID!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"The connection type for Comment."
type CommentSearchResultConnection {
  "A list of edges."
  edges: [CommentSearchResultEdge]
  "A list of nodes."
  nodes: [Comment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Time taken to complete the search in milliseconds."
  timeTaken: Int!
  "Total number of results."
  totalCount: Int!
}

"A comment search result edge."
type CommentSearchResultEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Comment
  "The relevancy score of the result. Higher scores mean more relevance."
  relevance: Float!
}

"A comment thread."
type CommentThread {
  "Look up comments."
  comments("Sort results by" sortBy: String "Sort direction" sortDirection: String "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentConnection!
  "The database ID for this comment thread."
  id: ID!
  "Time of when this comment thread was locked."
  lockedAt: DateTime
  "The user that locked this comment thread."
  lockedBy: User
  "Returns a boolean indicating whether this comment thread was moderated by an admin."
  moderatedByAdmin: Boolean!
  "The moderation status of this comment thread."
  moderationStatus: CommentThreadModerationStatus!
  "The thread owner"
  owner: User!
}

"Enum for available thread moderation states: \"none\", \"locked\""
enum CommentThreadModerationStatus {
  "The comment thread is not under moderation."
  none
  "The comment thread cannot be interacted with."
  locked
}

"Filter fields specific to the comments search query."
input CommentsSearchFilter {
  "Nested filters."
  filter: [CommentsSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Full text search query."
  query: [BaseFilterValue!]
  "The ID of the comment thread to search within."
  threadId: [BaseFilterValue!]
}

"Sort fields specific to the comments search query."
input CommentsSearchSort {
  "Sort by most relevant first."
  relevance: BaseSortValue
}

"Defines a Mod request using Game Domain and Mod ID"
input CompositeDomainWithIdInput {
  "Game domain"
  gameDomain: String!
  "Mod ID"
  modId: Int!
}

"Defines a Mod request using Game ID and Mod ID"
input CompositeIdInput {
  "Game ID"
  gameId: Int!
  "Mod ID"
  modId: Int!
}

"Autogenerated return type of CreateChangelogMutation."
type CreateChangelogMutationPayload {
  "Updated changelog ID"
  changelogId: Int!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of CreateCollectionBugReportMutation."
type CreateCollectionBugReportMutationPayload {
  "Collection bug report that was created"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of CreateCollectionMutation."
type CreateCollectionMutationPayload {
  "Returns created collection"
  collection: Collection!
  "The database ID for this collection."
  collectionId: Int!
  "Returns the collection revision which is created alongside the collection"
  revision: CollectionRevision!
  "The database ID for this collection revision."
  revisionId: Int!
  "Returns true when collection is successfully created."
  success: Boolean!
}

"Autogenerated return type of CreateCommentMutation."
type CreateCommentMutationPayload {
  "The comment that was created."
  comment: Comment!
}

"Autogenerated return type of CreateEndorsementMutation."
type CreateEndorsementMutationPayload {
  "Endorsement entry."
  endorsement: Endorsement!
  "Returns true when endorsement is created successfully."
  success: Boolean!
}

"Autogenerated return type of CreateMessage."
type CreateMessagePayload {
  "Returns true when message was sent."
  success: Boolean!
}

"Autogenerated return type of CreateNoteAboutUserMutation."
type CreateNoteAboutUserMutationPayload {
  "Moderation note created successfully"
  success: Boolean
}

"Autogenerated return type of CreateOrUpdateRevisionMutation."
type CreateOrUpdateRevisionMutationPayload {
  "Return the collection that was updated"
  collection: Collection!
  "The database ID for this collection."
  collectionId: Int!
  "Return the revision that was updated"
  revision: CollectionRevision!
  "The database ID for this revision."
  revisionId: Int!
  "The revision number"
  revisionNumber: Int!
  "Return true if the revision was updated"
  success: Boolean!
}

"Autogenerated return type of CreateRatingMutation."
type CreateRatingMutationPayload {
  "Average rating value of the entity the rating was created for."
  averageRating: AverageRating!
  "Rating entry."
  rating: Rating!
  "Returns true when rating is created successfully."
  success: Boolean!
}

"Autogenerated return type of CreateTagMutation."
type CreateTagMutationPayload {
  "Success Boolean"
  success: Boolean!
  "Created Tag"
  tag: Tag
}

"Scalar Type to parse and handle DateTimes in iso8601 format"
scalar DateTime

"Autogenerated return type of DiscardCollectionMutation."
type DiscardCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of DiscardCommentMutation."
type DiscardCommentMutationPayload {
  "The comment that was discarded."
  comment: Comment!
}

"Autogenerated return type of DiscardRevisionMutation."
type DiscardRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of DiscardTagMutation."
type DiscardTagMutationPayload {
  "Returns true if tag was discarded"
  success: Boolean!
}

"Autogenerated return type of EditCollectionMutation."
type EditCollectionMutationPayload {
  "Return collection object"
  collection: Collection!
  "Returns true if collection was updated"
  success: Boolean!
}

"An Endorsement"
type Endorsement {
  "Id of endorsed entity"
  modelId: Int!
  "Type of endorsed entity"
  modelType: Int!
  "Endorsement status: abstained\/endorsed"
  status: String!
  "The database ID for this endorsement."
  userId: Int!
}

"A mod file that is not hosted on Nexus Mods"
type ExternalResource {
  "Similar to the author field in the mod details. So this is not the\nuploader and may not be an actual user account on the page. Will often be unassigned for external resources"
  author: String
  "The database ID for this revision."
  collectionRevisionId: Int!
  "Glob pattern that must then match the archive file name. In cases where the collection asks for\na non-exact version (e.g.: 1.2.4 or newer) where we can't look at the hash of the expected file, this can be used to\ndetermine if the mod is already installed\/downloaded locally."
  fileExpression: String!
  "The database ID for this external resource."
  id: Int!
  "Deprecated"
  instructions: String @deprecated(reason: "This field is no longer being used")
  "Name of this resource"
  name: String!
  "If true, this is an optional resource"
  optional: Boolean!
  "Resource type. This can be one of \"direct\" (A url to\ndownload directly from), \"browse\" (A website url for the user to browse and manually select the right file on), \"manual\"\n (Vortex will just show instructions for the user to create\/acquire the mod manually)."
  resourceType: String!
  "Only set in the \"browse\"\/\"direct\" types, contains the url to\nbrowse to\/download from"
  resourceUrl: String
  "The version of the mod that the curator had installed at the time\nof uploading the collection."
  version: String
}

"An external video."
type ExternalVideo {
  "The embed URL for the video."
  embedUrl: String!
  "The external video ID."
  id: ID!
  "The platform where the video is hosted."
  platform: ExternalVideoPlatform!
  "The thumbnail URL for the video."
  thumbnailUrl: String!
  "The title of the video."
  title: String!
}

"Supported external video platforms."
enum ExternalVideoPlatform {
  "https:\/\/www.youtube.com"
  youtube
}

"A Mod File Hash"
type FileHash {
  "Time of when this file was first created."
  createdAt: DateTime!
  "Name of the file"
  fileName: String!
  "Filesize in bytes"
  fileSize: BigInt!
  "Type of file"
  fileType: String!
  "The database ID for this game."
  gameId: Int!
  "MD5 Checksum of the file"
  md5: String!
  "Mod file object"
  modFile: ModFile
  "The database ID for this file."
  modFileId: Int!
}

"Filter comparison operators for elastic search queries."
enum FilterComparisonOperator {
  EQUALS
  NOT_EQUALS
  "Matches if all terms in the value are present (in any order). No wildcarding, though stems may match."
  MATCHES
  "Matches if all terms in the value are present (in any order), with leading\/trailing wildcards applied."
  WILDCARD
  "Greater than"
  GT
  "Greater than or equal to"
  GTE
  "Less than"
  LT
  "Less than or equal to"
  LTE
}

"Filter logical operators for elastic search queries."
enum FilterLogicalOperator {
  "Logical AND"
  AND
  "Logical OR"
  OR
}

"Formal or informal moderation warning"
enum FormalOrInformalWarning {
  INFORMAL_WARNING
  FORMAL_WARNING
}

"A forum post"
type ForumPost {
  "Author ID of the forum post"
  authorId: Int!
  "Author name of the forum post"
  authorName: String!
  "The database ID for this forum post."
  id: Int!
  "Post contents"
  post: String!
  "Post date and time"
  postDate: Int!
  "Post author details"
  user: User!
}

"A forum topic"
type ForumTopic {
  "If true, this topic has been approved"
  approved: Boolean!
  "Description"
  description: String!
  "The database ID for this forum."
  forumId: Int!
  "The database ID for this forum topic."
  id: Int!
  "If true, this topic is pinned and should appear above all\nnon-pinned topics"
  pinned: Boolean!
  "List of all posts within this topic"
  posts: [ForumPost!]
  "Number of posts in thie topic"
  postsCount: Int!
  "State of this topic, can be open or closed"
  state: String!
  "Title for this topic"
  title: String!
  "SEO-specific title for this topic"
  titleSeo: String!
  "URL for this topic"
  topicUrl: String
  "Number of views this topic has received"
  views: Int!
  "TODO"
  visible: String!
}

"A Game"
type Game {
  "Time that this game was approved, after being submitted by a community member"
  approvedAt: DateTime
  "Tags available for collections under this specific game, including global tags."
  availableTags: [Tag!]
  "Number of collections within this game"
  collectionCount: Int
  "Nexus-specific domain name, used to separate games on the Nexus Mods website."
  domainName: String!
  "Number of total downloads for mods in this game"
  downloadCount: BigInt
  "URL to the game's forum"
  forumUrl: String
  "Genre of this game"
  genre: String
  "The database ID for this game."
  id: Int!
  "Number of uploaded images within this game"
  imageCount: Int
  "Number of uploaded images, supporter images, and videos within this game"
  mediaCount: Int
  "Number of mods within this game"
  modCount: Int
  "Name of this game"
  name: String!
  "Tags only available for collections under this specific game."
  specificTags: [Tag!]
  "Number of uploaded supporter images within this game"
  supporterImageCount: Int
  "The game image URL"
  tileImageUrl: String
  "Number of total unique downloads for mods in this game"
  uniqueDownloadCount: Int
  "Number of uploaded videos within this game"
  videoCount: Int
}

type GamePage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Nodes for pagination"
  nodes: [Game!]!
  "Aggregations available, if supported for this query and requested."
  nodesAggregations: [NodesAggregation!]
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A version of a specific game."
type GameVersion {
  "Unique ID for referring to this version in future queries"
  id: ID!
  "Game version reference"
  reference: String!
}

"Facet fields specific to the games query."
input GamesFacet {
  "Facet on game id."
  id: [String!]
  "Facet on game genre."
  genre: [String!]
  "Facet on collections."
  hasCollections: [String!]
  "Facet on Vortex support."
  supportsVortex: [String!]
}

"Filter for a list of Games"
input GamesSearchFilter {
  "Nested filters."
  filter: [GamesSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Game ID."
  id: [BaseFilterValue!]
  "Mod name."
  name: [BaseFilterValue!]
  "Date approved."
  approved: [BaseFilterValue!]
  "Number of mods."
  modCount: [BaseFilterValue!]
  "Number of downloads."
  downloadCount: [BaseFilterValue!]
  "Filter games by whether they have collections."
  hasCollections: [BooleanFilterValue!]
  "Number of collections."
  collectionCount: [BaseFilterValue!]
  "Number of media."
  mediaCount: [BaseFilterValue!]
  "Number of images."
  imageCount: [BaseFilterValue!]
  "Number of videos."
  videoCount: [BaseFilterValue!]
  "Number of supporter images."
  supporterImageCount: [BaseFilterValue!]
  "Game genre."
  genre: [BaseFilterValue!]
  "Filter games by whether they support Vortex."
  supportsVortex: [BooleanFilterValue!]
}

"Sort for a list of Games"
input GamesSearchSort {
  "Mod name."
  name: BaseSortValue
  "Number of mods."
  mods: BaseSortValue
  "Number of downloads."
  downloads: BaseSortValue
  "Number of collections."
  collections: BaseSortValue
  "Number of media."
  media: BaseSortValue
  "Number of images."
  images: BaseSortValue
  "Number of videos."
  videos: BaseSortValue
  "Number of supporter images."
  supporterImages: BaseSortValue
  "Date approved."
  approved: BaseSortValue
}

"Autogenerated return type of GiveKudosMutation."
type GiveKudosMutationPayload {
  "True if the user was successfully given kudos"
  success: Boolean!
}

"A globally identifiable entity."
interface GloballyIdentifiable {
  "The global ID for this entity."
  globalId: ID
  "ID of the object."
  id: ID!
}

"Autogenerated return type of HideCollectionBugReportMutation."
type HideCollectionBugReportMutationPayload {
  "Collection bug report which was hidden"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of HideCommentMutation."
type HideCommentMutationPayload {
  "The comment that was hidden."
  comment: Comment!
}

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Available image types"
enum ImageTypes {
  gallery
  tile
  header
}

"An integer value"
input IntFilterValue {
  "Integer Value"
  value: Int!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Autogenerated return type of IssueWarningToUserMutation."
type IssueWarningToUserMutationPayload {
  "Warning issued successfully"
  success: Boolean
}

"Autogenerated return type of LikeCommentMutation."
type LikeCommentMutationPayload {
  "The comment that was liked."
  comment: Comment!
}

"Autogenerated return type of ListCollectionMutation."
type ListCollectionMutationPayload {
  "Returns true if collection was listed"
  success: Boolean!
}

"Autogenerated return type of LockCommentMutation."
type LockCommentMutationPayload {
  "The comment that was locked."
  comment: Comment!
}

"Autogenerated return type of LockThreadMutation."
type LockThreadMutationPayload {
  "The comment thread that was locked."
  commentThread: CommentThread!
}

"A mod"
type Mod {
  "If true, this mod contains adult content"
  adult: Boolean @deprecated(reason: "Deprecated in favour of `adult_content`.")
  "If true, this mod contains adult content"
  adultContent: Boolean
  "Author of this mod"
  author: String
  "Category of this mod"
  category: String!
  "Time of when this mod was first created."
  createdAt: DateTime!
  "A detailed description of this mod"
  description: String!
  "Download count of this mod"
  downloads: Int!
  "Endorsement count of this mod"
  endorsements: Int!
  "Size of the primary mod file in kilobytes"
  fileSize: Int
  "Game changed by this mod"
  game: Game!
  "The database ID for this game."
  gameId: Int!
  "The database ID for this mod."
  id: ID!
  "Mirrors for this mod"
  mirrors: [ModMirror!]
  "A mod category"
  modCategory: ModCategory
  "The database ID for this mod."
  modId: Int!
  "Name of this mod"
  name: String!
  "URL for the main mod image"
  pictureUrl: String
  "Status of this mod"
  status: String!
  "A brief summary of this mod"
  summary: String!
  "URL for the thumbnail mod image"
  thumbnailUrl: String
  "The database ID for this mod."
  uid: ID!
  "Time of when this mod was last updated."
  updatedAt: DateTime!
  "Uploader of this mod"
  uploader: User!
  "Version of this mod"
  version: String!
  "True if the viewer (current user) has blocked this mod"
  viewerBlocked: Boolean!
  "A timestamp indicating the last time the user downloaded this mod"
  viewerDownloaded: DateTime
  "True indicates endorsement, false for\n abstention. Will be null if the user has not endorsed the mod"
  viewerEndorsed: Boolean
  "If true, the viewer (current user) is tracking this mod."
  viewerTracked: Boolean!
  "True if the mod has been updated since the viewer (curent user) downloaded it"
  viewerUpdateAvailable: Boolean
}

"A mod category"
type ModCategory {
  "The database ID for this mod category."
  categoryId: Int!
  "Unix timestamp of category creation"
  date: Int
  "The database ID for this game."
  gameId: Int!
  "Comma separated mod category id and game id"
  id: ID!
  "Name of this category"
  name: String!
  "Comma separated list of legacy tag IDs"
  tags: String @deprecated(reason: "These tag identifiers are no longer used")
}

"The connection type for User."
type ModEndorserConnection {
  "A list of edges."
  edges: [ModEndorserEdge]
  "A list of nodes."
  nodes: [User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Mod endorser edge"
type ModEndorserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "Time of endorsement"
  endorsedAt: DateTime!
  "The item at the end of the edge."
  node: User
}

"Files belonging to a mod"
type ModFile implements Node {
  "Human-readable mod category"
  category: ModFileCategory!
  "The database ID for this Mod category."
  categoryId: ModFileCategory!
  "Patch notes for this mod file version"
  changelogText: [String!]!
  "Number of downloads for this file"
  count: Int!
  "Unix Timestamp for when this file was uploaded"
  date: Int!
  "Description for this file"
  description: String
  "Forms a composite key with the game_id"
  fileId: Int!
  "Game that this file relates to"
  game: Game!
  "ID of the object."
  id: ID!
  "If true, this file can be downloaded by a mod manager"
  manager: Int!
  "Mod that this file belongs to"
  mod: Mod!
  "The database ID for this mod."
  modId: Int!
  "File name"
  name: String!
  "User that uploaded this file"
  owner: User!
  "If true, this file is the primary file for the mod"
  primary: Int!
  "URL for reporting this file"
  reportLink: String!
  "If true, popup will be displayed for showing the requirements"
  requirementsAlert: Int!
  "Status of virus scanning on this file"
  scanned: VirusScanStatus!
  "Size of this file, in kilobytes"
  size: Int!
  "Size of this file, in bytes"
  sizeInBytes: BigInt
  "Number of downloads for this file"
  totalDownloads: Int!
  "Number of unique downloads for this file"
  uCount: Int!
  "Unique ID for this file"
  uid: ID!
  "Number of unique downloads for this file"
  uniqueDownloads: Int!
  "URL to download this file"
  uri: String!
  "Version this file relates to"
  version: String!
}

"Used to flag a mod file as a main, old or archived file."
enum ModFileCategory {
  MAIN
  UPDATE
  OPTIONAL
  OLD_VERSION
  MISCELLANEOUS
  REMOVED
  ARCHIVED
}

type ModFilePage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Nodes for pagination"
  nodes: [ModFile!]!
  "Aggregations available, if supported for this query and requested."
  nodesAggregations: [NodesAggregation!]
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A download mirror for a mod"
type ModMirror {
  "Download count for this mirror"
  count: Int
  "The database ID for this game."
  gameId: Int!
  "The database ID for this mod mirror."
  id: ID!
  "The database ID for this mod."
  modId: Int!
  "Name of this mirror"
  name: String!
  "Download count for this mirror"
  totalDownloads: Int
  "URI for this mirror"
  uri: String
}

type ModPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Nodes for pagination"
  nodes: [Mod!]!
  "Aggregations available, if supported for this query and requested."
  nodesAggregations: [NodesAggregation!]
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"Used to define the source of a mod. Useful for informing Collections how to retrieve\nmods."
enum ModSource {
  "The Nexus website"
  nexus
  "A direct url to download from"
  direct
  "A general url to find the mod (further instructions may be provided)"
  browse
  "Manual instructions for installing the mod"
  manual
  "Mod files are included in the collection asset file, and do not need to be acquired separately"
  bundle
}

"An upload"
type ModUpload {
  "If true, this file has been claimed by a user"
  claimed: Boolean
  "If true, the content preview has been generated for this upload"
  contentPreviewGenerated: Boolean
  "Time of when this upload was first created."
  createdAt: String!
  "Time of when this upload was discarded."
  discardedAt: String
  "If true, this file has been reassembled from the uploaded chunks"
  fileChunksReassembled: Boolean
  "Can't get field description; multiple fields named 'file_id' detected on Types::ModFileType"
  fileId: Int
  "A Game"
  game: Game
  "The database ID for this upload."
  id: String!
  "The virus scanning status of this upload, provided by our internal virus scanning tools"
  internalVirusScanStatus: Int
  "The MD5 hash for this object in our object store"
  md5: String
  "Files belonging to a mod"
  modFile: ModFile
  "The database ID for this mod."
  modId: Int
  "If true, this file has been uploaded to object store"
  s3UploadComplete: Boolean
  "The URL for this object in our object store"
  s3Url: String
  "The HAS256 hash for this object in our object store"
  sha256: String
  "The size of this upload in bytes"
  sizeBytes: String
  "System filename for this upload"
  systemFileName: String
  "Temporary filename for this upload"
  tempFileName: String!
  "Time of when this upload was last updated."
  updatedAt: String!
  "Type of upload"
  uploadType: String
  "A Nexus Mods user"
  user: User
  "Number of positive reports from VirusTotal"
  virusTotalPositives: Int
  "The virus scanning status of this upload, provided by VirusTotal"
  virusTotalStatus: Int
  "The URL of the VirusTotal report for this upload"
  virusTotalUrl: String
}

"Moderatable Model Types"
enum Moderatable {
  "A nexusmods Collection of Mods"
  Collection
}

"Autogenerated return type of ModerateMutation."
type ModerateMutationPayload {
  "Return the moderation type"
  moderation: Moderation!
  "if true, this entity is put into moderation"
  success: Boolean!
}

"A moderation entry"
type Moderation {
  "Time of when this moderation was first created."
  createdAt: DateTime!
  "If true, this moderation entry can be edited"
  editable: Boolean!
  "The database ID for this moderation."
  id: ID!
  "Polymorphic ID of the entity that is being moderated"
  moderatableId: ID!
  "Polymorphic Type of the entity that\nis being moderated"
  moderatableType: Moderatable!
  "Array of fixes applied for this\nmoderation"
  moderationFixes: [ModerationFix!]
  "Reason for placing this entity\ninto moderation"
  moderationReason: ModerationReason!
  "The database ID for this staff member."
  staffId: ID!
  "Content for the staff note"
  staffNote: String
  "Date this entity was unlocked"
  unlockedAt: DateTime
  "User that unlocked this entity"
  unlockedBy: ID
  "Content for the message to show when unlocked"
  unlockedNote: String
  "Time of when this moderation was last updated."
  updatedAt: DateTime!
  "Staff member that put this entity into moderation"
  user: User!
  "Content for the user note"
  userNote: String
}

"A moderation fix submission"
type ModerationFix {
  "User who authored this moderation fix"
  author: User!
  "ID of the user who authored this moderation fix"
  authorId: ID!
  "Time of when this moderation fix was first created."
  createdAt: DateTime!
  "Description of this moderation fix"
  description: String
  "The database ID for this moderation fix."
  id: ID!
  "Type of moderation fix"
  moderation: Moderation!
  "Status of this moderation fix"
  status: ModerationFixStatus!
  "Time of when this moderation fix was last updated."
  updatedAt: DateTime!
}

"Available moderation fix statuses"
enum ModerationFixStatus {
  "Awaiting an Admin's approval"
  submitted
  "An Admin has accepted this fix"
  accepted
  "An Admin has rejected this fix"
  rejected
}

"A moderation reason"
type ModerationReason {
  "Time of when this moderation reason was first created."
  createdAt: DateTime!
  "The database ID for this moderation reason."
  id: ID!
  "Reason for moderation"
  reason: String!
  "Resolution of the moderation"
  resolution: String
  "Time of when this moderation reason was last updated."
  updatedAt: DateTime!
}

"A moderation restriction"
input ModerationRestriction {
  "Reason"
  restriction: ModerationRestrictions!
  "Timeframe in days"
  timeframe: Int!
  "Mod ID"
  modId: ID
  "Game ID"
  gameId: ID
}

"Moderation restriction types"
enum ModerationRestrictions {
  FILE_UPLOAD
  MOD_TOOLS
  FILE_DOWNLOAD
  POST
  COMMENT_FILE
  IMAGE_UPLOAD
  ENDORSE_MOD
  ENDORSE_MEDIA
  BLOCK_PM
  ADD_VIDEOS
}

"Autogenerated return type of ModifyImageForCollectionMutation."
type ModifyImageForCollectionMutationPayload {
  "Image that was updated on the collection"
  image: CollectionImage!
  "True when image was updated"
  updated: Boolean!
}

"Facet fields specific to the mods query."
input ModsFacet {
  "Facet on game domain name."
  gameDomainName: [String!]
  "Facet on game name."
  gameName: [String!]
  "Facet on game id."
  gameId: [String!]
  "Facet on adult."
  adult: [String!]
  "Facet on language."
  languageName: [String!]
  "Facet on status."
  status: [String!]
  "Facet on category."
  categoryName: [String!]
  "Facet on tag."
  tag: [String!]
}

"Filter fields specific to a Mods query"
input ModsFilter {
  "Nested filters."
  filter: [ModsFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Mod name suitable for use with op:wildcard, but not op:matches. Punctuation matched."
  name: [BaseFilterValue!]
  "Stemmed name, suitable for token matching (op:wildcard and op:matches). Punctuation not matched."
  nameStemmed: [BaseFilterValue!]
  "Filter mods by Game ID"
  gameId: [BaseFilterValue!]
  "Filter mods by Game domain name"
  gameDomainName: [BaseFilterValue!]
  "Date created, in unix timestamp"
  createdAt: [BaseFilterValue!]
  "Date updated, in unix timestamp"
  updatedAt: [BaseFilterValue!]
  "Filter mods by whether they have been updated since they were created"
  hasUpdated: [BooleanFilterValue!]
  "Filter mods by uploader id"
  uploaderId: [BaseFilterValue!]
  "Filter mods by adult content"
  adultContent: [BooleanFilterValue!]
  "Filter mods by file size"
  fileSize: [IntFilterValue!]
  "Filter mods by download count"
  downloads: [IntFilterValue!]
  "Filter mods by endorsement count"
  endorsements: [IntFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "The description of the mod"
  description: [BaseFilterValue!]
  "The name of the author"
  author: [BaseFilterValue!]
  "The name of the uploader"
  uploader: [BaseFilterValue!]
  "Filter mods by whether they support Vortex"
  supportsVortex: [BooleanFilterValue!]
}

"Sort fields specific to a Mods query."
input ModsSort {
  "Filter query relevance, works best with non wildcard queries."
  relevance: BaseSortValue
  "Mod name."
  name: BaseSortValue
  "Number of times downloaded."
  downloads: BaseSortValue
  "Number of unique downloads."
  uniqueDownloads: BaseSortValue
  "Number of times endorsed."
  endorsements: BaseSortValue
  "Random mods."
  random: RandomSortValue
  "Date created."
  createdAt: BaseSortValue
  "Date updated."
  updatedAt: BaseSortValue
  "Mod file size."
  size: BaseSortValue
  "Date of last comment."
  lastComment: BaseSortValue
}

"All mutations to update, create and delete data"
type Mutation {
  "Marks the fix as accepted and takes the collection out of moderation.\nOnly collection moderators can call this mutation"
  acceptModerationFix("The database ID for this moderation fix." moderationFixId: ID!): AcceptModerationFixMutationPayload
  "Adds a game to a user's favourites"
  addFavouriteGame("The game to add" gameId: ID!): AddFavouriteGameMutationPayload
  "Adds a new header image to a collection"
  addHeaderImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID!): AddHeaderImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new image to a collection"
  addImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID! "ID of collection revision to add image to" collectionRevisionId: ID): AddImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a tag to a collection. User must have the `collection:add_tag` permission"
  addTagToCollection("IDs of tags to add to the collection" tagIds: [ID!]! "ID of collection to add tags to" collectionId: Int!): AddTagToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new tile image to a collection"
  addTileImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID!): AddTileImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new image to a collection"
  addVideoToCollection("Video to be added" video: UploadVideoInput! "ID of collection to add video to" collectionId: ID! "ID of collection revision to add video to" collectionRevisionId: ID): AddVideoToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates existing Moderation entity. Used to update details about the moderation or to unlock it."
  amendModeration("ID of the Moderation entity" id: ID! "Note displayed to the end user." userNote: String "Note displayed to internally to staff members." staffNote: String "Enable or disable editing of the entity." editable: Boolean "When TRUE, the entity will no longer be moderated." unlocked: Boolean "Note for the end user when moderation is\nunlocked" unlockedNote: String "Change collection\nstatus upon amending the moderation." collectionStatus: CollectionStatus "Change moderation reason." moderationReasonId: ID): AmendModerationMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Changes a collection owner."
  changeCollectionOwner("Collection ID" collectionId: ID! "New owner ID" ownerId: ID!): ChangeCollectionOwnerPayload
  "Clears the status of an existing bug report on a collection"
  clearCollectionBugReportModerationStatus("ID of the collection bug report to clear status of" bugReportId: ID!): ClearCollectionBugReportModerationStatusMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Clears the moderation status of a comment."
  clearCommentModerationStatus("The database ID for this comment." commentId: ID!): ClearCommentModerationStatusMutationPayload
  "Clears the moderation status of a comment thread."
  clearCommentThreadModerationStatus("The database ID for this comment thread." commentThreadId: ID!): ClearThreadModerationStatusMutationPayload
  "Marks a collection bug report as closed. Can be called by the reporter or the collection curator, but only the curator can specify a closure_reason"
  closeCollectionBugReport("ID of the collection bug report to close" bugReportId: ID! "The status of the bug report, e.g. Resolved, Won't fix" closureReason: BugReportClosureReason!): CloseCollectionBugReportMutationPayload
  "Creates a revision changelog entry"
  createChangelog("Revision ID" revisionId: ID! "Changelog description" description: String!): CreateChangelogMutationPayload
  "Create a new Collection. Must be passed the collection data from the manifest containing\n  the manifest schema."
  createCollection("Collection payload required for the collection creation." collectionData: CollectionPayload! "UUID of the temporary collection file. Once the creation process is completed,\n  the file will be moved to a permanent storage space." uuid: String!): CreateCollectionMutationPayload
  "Creates a new bug report for a collection"
  createCollectionBugReport("ID of collection to add bug report to" collectionId: ID! "Number of collection revision to add bug report to" collectionRevisionNumber: Int! "Title of the new bug report" title: String! "Description for the new bug report" description: String "Array of attachment ids of uploaded files" attachmentIds: [ID!]): CreateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Creates a comment."
  createComment("The database ID for this comment thread." commentThreadId: ID! "The comment body." body: String! "An optional comment ID to reply to." replyToId: ID "An optional array of attachment_ids from uploaded files to attach." attachmentIds: [ID!]): CreateCommentMutationPayload
  "Create a new message"
  createMessage("User IDs of recipients" to: [Int!]! "Title of message" title: String! "Body of message" body: String!): CreateMessagePayload
  "Creates a moderation note about a user"
  createNoteAboutUser("The database ID for this user." userId: ID! "The moderation note" note: String!): CreateNoteAboutUserMutationPayload
  "Creates a new Collection Revision, or updates an existing Collection Revision (if a\n  draft already exists )"
  createOrUpdateRevision("The data payload used to create a collection revision" collectionData: CollectionPayload! "The database ID for this collection." collectionId: Int! "TODO" uuid: String!): CreateOrUpdateRevisionMutationPayload
  "Creates a new collection Tag"
  createTag("Tag name" name: String! "Tag category ID" categoryId: ID "Array containing Game IDs to\nbe associated with the tag" gameIds: [ID!] "Is the tag global\n(not game specific)" global: Boolean "Is this an adult content tag" adult: Boolean): CreateTagMutationPayload
  "Discards an entire Collection and its associated entities"
  discardCollection("Collection ID" collectionId: ID! "Discard reason" reason: String!): DiscardCollectionMutationPayload
  "Discards a comment."
  discardComment("The database ID for this comment." commentId: ID!): DiscardCommentMutationPayload
  "Discards a Collection Revision. Revision can only be discarded if it is a DRAFT or is not older than\n24 hours and has no more than a 100 unique downloads."
  discardRevision("Collection ID" collectionId: ID! "Revision number" revisionNumber: Int! "Discard Reason" reason: String): DiscardRevisionMutationPayload
  "Removed an existing tag. User must have the `tag:discard` permission"
  discardTag("The database ID for this category." id: ID!): DiscardTagMutationPayload
  "Updates the core details for a collection such as the name, description and category"
  editCollection("The database ID for this collection." collectionId: Int! "Name of this collection" name: String "Collection summary" summary: String "Description of this collection" description: String "ID of the parent category" categoryId: ID "If true, allow user-uploaded content" allowUserMedia: Boolean "If true, media needs to be verified" manuallyVerifyMedia: Boolean): EditCollectionMutationPayload
  "Creates an endorsement for a generic Endorsable model. TODO: This will be moving to a\nmodel-specific mutation"
  endorse("Used to determine whether the endorsement entry is used for abstaining.\nUsers that abstain from endorsing a file will not get send future endorsement reminders." abstain: Boolean "ID of an entity the endorsement is for." modelId: Int! "Type of an entity the endorsement is for." modelType: String!): CreateEndorsementMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Allows the current user to give kudos to another user"
  giveKudos("The ID of the user to give kudos to." kudosUserId: ID): GiveKudosMutationPayload
  "Hides a bug report on a collection from public view"
  hideCollectionBugReport("ID of the collection bug report to hide" bugReportId: ID! "Public reason to hide the bug report" reason: String "Company internal reason to hide the bug report" internalReason: String): HideCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Hides a comment."
  hideComment("The database ID for this comment." commentId: ID! "The reason for hiding the comment." reason: String! "The internal reason for hiding the comment. Only visible to admins and moderators." internalReason: String): HideCommentMutationPayload
  "Issues a moderation warning to a user"
  issueWarningToUser("The database ID for this user." userId: ID! "Whether the warning is informal or formal" warning: FormalOrInformalWarning! "The reason for the warning" reason: String! "The public reason for the warning" publicReason: String "Reference links for the warning" referenceLinks: [String!] "The database ID for this comment." commentId: ID "Restrictions to apply to the user" restrictions: [ModerationRestriction!]): IssueWarningToUserMutationPayload
  "Likes a comment."
  likeComment("The database ID for this comment." commentId: ID!): LikeCommentMutationPayload
  "Sets a collection as `listed`. A collection can only be listed if there are published revisions.\nUser must have the `collection:set_status` permission"
  listCollection("The database ID for this collection." collectionId: Int!): ListCollectionMutationPayload
  "Locks a comment."
  lockComment("The database ID for this comment." commentId: ID!): LockCommentMutationPayload
  "Locks a comment thread."
  lockCommentThread("The database ID for this comment thread." commentThreadId: ID!): LockThreadMutationPayload
  "Sets a collection as `under_moderation`, allowing the user to provide a reason and the\nability to 'lock' the collection against future editing. User must have the `collection:moderate` permission."
  moderate("Moderatable ID - ID of the object intended to be moderated" id: ID! "Moderatable type" type: Moderatable! "Moderation note visible to the user" userNote: String "Moderation note only visible to staff" staffNote: String "If true, this entity cannot be edited by the author" editable: Boolean "The database ID for this moderation reason." moderationReasonId: ID!): ModerateMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates an image on a collection"
  modifyImageForCollection("Image to be updated" image: UpdateImageInput! "ID of collection to update image on" collectionId: ID!): ModifyImageForCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Re-opens a previously closed bug report. Can be called by the report or the collection curator"
  openCollectionBugReport("ID of the collection bug report to open" bugReportId: ID!): OpenCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Pins a comment. User must have the `comment:pin?` permission"
  pinComment("The database ID for this comment." commentId: ID!): PinCommentMutationPayload
  "Publishes a Collection Revision"
  publishRevision("Collection Revision ID" revisionId: ID! "Allows a curator to\nset the collection status when this revision is published" collectionStatus: CollectionStatus "Does this revision contain adult content\nresources" hasAdultResources: Boolean): PublishRevisionMutationPayload
  "Votes for a generic Rateable model. TODO: This will be moved to model-specific mutations"
  rate("ID of the entity the rating is for" id: ID! "Type of the entity the rating is for" type: Ratable! "Rating value" rating: RatingOptions!): CreateRatingMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Marks the moderation fix as rejected. The collection status is not changed.\nOnly collection moderators can call this mutation"
  rejectModerationFix("The database ID for this moderation fix." moderationFixId: ID!): RejectModerationFixMutationPayload
  "Removes the current user's like from a comment."
  removeCommentLike("The database ID for this comment." commentId: ID!): RemoveCommentLikeMutationPayload
  "Removes a game from a user's favourites"
  removeFavouriteGame("The game to remove" gameId: ID!): RemoveFavouriteGameMutationPayload
  "Removes a header image from a Collection"
  removeHeaderImageFromCollection("The database ID for this collection." collectionId: ID!): RemoveHeaderImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes an image from a Collection"
  removeImageFromCollection("The database ID for this image." imageId: ID! "The database ID for this collection." collectionId: ID!): RemoveImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Allows the current user to remove kudos from another user"
  removeKudos("The ID of the user to remove kudos from." kudosUserId: ID): RemoveKudosMutationPayload
  "Removes tags from a collection"
  removeTagFromCollection("Array containing Tag IDs" tagIds: [ID!]! "Collection ID" collectionId: ID!): RemoveTagFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes a tile image from a Collection"
  removeTileImageFromCollection("The database ID for this collection." collectionId: ID!): RemoveTileImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes a video from a Collection"
  removeVideoFromCollection("The database ID for this video." videoId: ID! "The database ID for this collection." collectionId: ID!): RemoveVideoFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Moves an item to a new position in a list."
  reorderItem("The global ID of the item to move." id: ID! "The global ID of the item to move towards." targetId: ID! "The new location of the item, in relation to the target item." location: ReorderLocation!): ReorderItemPayload
  "Reorders pinned comments. User must have the `comment:pin?` permission"
  reorderPinnedComments("The database ID for this comment." commentIds: [ID!]!): ReorderPinnedCommentsMutationPayload
  "Create a collection report"
  reportCollection("Collection ID" collectionId: ID! "Report reason" reason: String! "Report description" description: String!): ReportCollectionMutationPayload
  "Creates a report on a collection bug report"
  reportCollectionBugReport("ID of the collection bug report to report" collectionBugReportId: ID! "Reason for the new report" reason: String! "Description for the new report" description: String!): ReportCollectionBugReportMutationPayload
  "Reports a comment for abuse."
  reportComment("The database ID for this comment." commentId: ID! "The reason for reporting the comment." reason: String! "A more detailed reason for reporting the comment." description: String!): ReportCommentMutationPayload
  "Restores a discarded comment."
  restoreComment("The database ID for this comment." commentId: ID!): RestoreCommentMutationPayload
  "Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as\na revision that should not be used anymore."
  retractRevision("Collection Revision ID" revisionId: ID! "Retraction Reason" reason: String!): RetractRevisionMutationPayload
  "Submits a moderation fix against a moderation that is pending acceptance"
  submitModerationFix("The database ID for this moderation fix." moderationId: ID! "Additional information from the curation for\nthis fix" description: String): SubmitModerationFixMutationPayload
  "Allows the current user to track another user"
  trackUser("The ID of the user to be tracked." trackedUserId: ID): TrackUserMutationPayload
  "Unlists a Collection Revision from the public Nexus Mods pages."
  unlistCollection("Collection ID" collectionId: ID!): UnlistCollectionMutationPayload
  "Unpins a comment. User must have the `comment:unpin?` permission"
  unpinComment("The database ID for this comment." commentId: ID!): UnpinCommentMutationPayload
  "Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as\na revision that should not be used anymore."
  unpublishRevision("Collection Revision ID" revisionId: ID! "Retraction Reason" reason: String!): RetractRevisionMutationPayload @deprecated(reason: "Legacy Field - this will be removed in a future update.")
  "Makes the current user stop tracking another user"
  untrackUser("The ID of the user to stop tracking." trackedUserId: ID): UntrackUserMutationPayload
  "Updates a user's bio (About Me) on their profile"
  updateAboutMe("The user whose bio we are updating (or current user if nil)." userId: ID "The new text for the about me section in bio." about: String!): UpdateAboutMeMutationPayload
  "Updates existing revision changelog"
  updateChangelog("Changelog ID" changelogId: ID! "Changelog description" description: String!): UpdateChangelogMutationPayload
  "Updates a bug report on a collection"
  updateCollectionBugReport("ID of the collection bug report to update" bugReportId: ID! "Number of collection revision to update bug report on" collectionRevisionNumber: Int "Title of the new bug report" title: String! "Description of the new bug report" description: String "Array of attachment ids" attachmentIds: [ID!]): UpdateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates a comment."
  updateComment("The database ID for this comment." commentId: ID! "The comment body." body: String! "An array of attachment_ids of uploaded files to attach to the new revision.Include all the previous ids or they won't be present on the updated revision.If you don't send an array the previous revisions attachments will be maintained" attachmentIds: [ID!]): UpdateCommentMutationPayload
  "Updates a user's country on their profile"
  updateCountry("The user whose country to update (current user if omitted)." userId: ID "ISO Country Code (can also be null)" country: String): UpdateCountryMutationPayload
  "Updates a specific Collection Revision with new installation information and adult\ncontent flags"
  updateRevision("ID of the collection revision to update" revisionId: Int! "User-provided installation information" installationInfo: String "Whether this revision has adult content" adultContent: Boolean): UpdateRevisionMutationPayload
  "Updates a collection Tag"
  updateTag("Collection Tag ID" id: ID! "Tag name" name: String "Tag category ID" categoryId: ID "Games IDs to be associated with the Tag" gameIds: [ID!] "Is the tag global (non game specific)" global: Boolean "Is this an adult content Tag" adult: Boolean): UpdateTagMutationPayload
  "Uploads a file to later be attached to an Attachable entity"
  uploadAttachment("A file to upload that will be later attached to an entity" file: Upload!): UploadAttachmentMutationPayload
  "Writes a full page notification to a user"
  writeFullPageNotificationToUser("The database ID for this user." userId: ID! "The full page notification title" title: String! "The full page notification message" message: String! "The full page notification reference links" referenceLinks: [String!]): WriteFullPageNotificationToUserMutationPayload
}

"A News article, stored and originally defined by the legacy forum"
type News {
  "Author of this News Article"
  author: User!
  "Content of this news article"
  content: String!
  "Date this news article was created"
  date: ISO8601DateTime!
  "Games this news article is related to"
  games: [Game!]!
  "The name of the image on the forum"
  header: String
  "Is this news article written in HTML?"
  html: Boolean!
  "The database ID for this news."
  id: ID!
  "The name of the image on the forum"
  image: String
  "Category of this news article"
  newsCategory: NewsCategory!
  "If the news article has a source, this is it's name"
  sourceName: String
  "If the news article has a source, this is the URL"
  sourceUrl: String
  "Title of this news article"
  title: String!
  "The name of the uncropped image on the forum"
  uncroppedHeader: String
  "The name of the uncropped image on the forum"
  uncroppedImage: String
}

"A news category"
type NewsCategory {
  "The database ID for this news category."
  id: ID!
  "Name of this category"
  name: String!
}

"Forum news articles type."
enum NewsCategoryEnum {
  SITE_NEWS
  GAME_NEWS
  MOD_NEWS
  INTERVIEWS
  COMPETITIONS
  FEATURES
}

type NewsPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Nodes for pagination"
  nodes: [News!]!
  "Aggregations available, if supported for this query and requested."
  nodesAggregations: [NodesAggregation!]
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"An object with an ID."
interface Node {
  "ID of the object."
  id: ID!
}

"Metadata about aggregation in a set of nodes"
type NodesAggregation {
  "Key"
  key: String!
  "Name"
  name: String!
  "Nested aggregations"
  sub: [NodesAggregation!]!
  "Valuje"
  value: Int!
}

"Metadata about a single facet value."
type NodesFacet {
  "Number of results available for this facet value. Affected by values set on other facets."
  count: Int!
  "Name matching the graphql facet request."
  facet: String!
  "Value available for this facet. May be used in a subsequent facet request to filter the results by facet."
  value: String!
}

"Types of object which can be recorded in an action log"
enum ObjectType {
  MOD
  IMAGE
  MOD_IMAGE
  CHANGELOG
  FILE
  MIRROR
  MOD_VIDEO
  README
  FRIEND
  ARTICLE
  COMMENT
  SUPPORTER_IMAGE
  ATTRIBUTE
  VIDEO
  MOD_NOTE
  MOD_MODERATION_INFO
  MOD_REQUIREMENT
  PREFERENCE
  IMAGE_MODERATION_INFO
  NEWS
  NEWS_IMAGE
  NEWS_HEADER
  MOD_BUG
  MOD_BUG_REPLY
  MOD_CATEGORY
  SUPPORTER_IMAGE_MODERATION_INFO
  VIDEO_MODERATION_INFO
  ADVERT
  USER
  GAME
}

"Autogenerated return type of OpenCollectionBugReportMutation."
type OpenCollectionBugReportMutationPayload {
  "Collection bug report which was re-opened"
  collectionBugReport: CollectionBugReport!
}

"Represents a single opted in mod"
type OptedInMod {
  "Time of when this OptedInMod was first created."
  createdAt: DateTime!
  "Game"
  game: Game
  "The ID of the game the mod belongs to"
  gameId: Int!
  "The database ID for this opted in mod."
  id: Int!
  "Mod"
  mod: Mod
  "ID of the that was opted in"
  modId: Int!
  "Ratio of the DP from this mod shared with this user"
  ratio: Float!
  "Uploader of the mod"
  uploader: User
  "ID of the uploader of the mod. This\nmight not be the current user, as mod authors can share mod DP with other users."
  uploaderId: Int!
}

"A list of mods that this user has been opted into"
type OptedInMods {
  "Number of mods this user has opted in"
  count: Int!
  "Mods that have been opted\nin"
  entries: [OptedInMod!]!
  "User"
  user: User!
  "ID of the user"
  userId: Int!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"An entity to represent either an account or a bank"
type PaymentEntity {
  "The database ID for this payment entity."
  id: Int!
  "Name of this entity"
  label: String!
  "Type of entity"
  type: String!
}

"A global or entity-specific permission granted to a user"
type Permission {
  "If true, this permission is being granted globally from the user's role"
  global: Boolean!
  "Permission string being granted E.g. 'collection:publish'"
  key: String!
}

"Autogenerated return type of PinCommentMutation."
type PinCommentMutationPayload {
  "The comment that was pinned."
  comment: Comment!
}

"returned attributes for presigned post requests"
type PresignedUrl {
  "Presigned URL"
  url: String!
  "UUID"
  uuid: String!
}

"A public changelog attached to a collection revision.\n      If you need to access more fields, use CollectionChangelogType instead."
type PublicCollectionChangelog {
  "The id of the collection revision for which this changelog was created"
  collectionRevisionId: Int!
  "Time of when this collection changelog was first created."
  createdAt: DateTime!
  "The content of the collection changelog, in Markdown format"
  description: String!
  "The database ID for this collection changelog."
  id: Int!
  "The revision number of the collection revision for which this changelog was created"
  revisionNumber: Int!
  "Time of when this collection changelog was last updated."
  updatedAt: DateTime!
}

"A public collection revision type.\n      If you need to access more fields, use CollectionRevisionType instead."
type PublicCollectionRevision {
  "A changelog attached to a collection revision"
  collectionChangelog: PublicCollectionChangelog
  "Time of when this revision was first created."
  createdAt: DateTime!
  "Time of when this revision was discarded."
  discardedAt: DateTime
  "The database ID for this revision."
  id: Int!
  "An average taken from all ratings for this revision"
  overallRating: String
  "A count of all ratings for this revision"
  overallRatingCount: Int
  "Average rating for a single revision and total number of votes"
  rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
  "The revision number"
  revision: Int! @deprecated(reason: "Use `revision_number` instead.")
  "The revision number"
  revisionNumber: Int!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  revisionStatus: String!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"Autogenerated return type of PublishRevisionMutation."
type PublishRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Queries for fetching and filtering data"
type Query {
  "Get a list of categories"
  categories("Game ID" gameId: Int "If true, include all global categories" global: Boolean): [Category!]
  "Get a category by ID"
  category("Category ID" id: ID!): Category
  "Get a collection by slug"
  collection("Unique slug for a collection" slug: String "Overrides adult content in user preferences" viewAdultContent: Boolean "Specifies game domain. Will return a NOT_FOUND\n response if invalid domain is passed." domainName: String): Collection!
  "Get a list of Games containing 1 or more collections with the collection counts"
  collectionGames: [Game!]
  "Get a revision by collection slug and revision number"
  collectionRevision("Unique slug for a collection" slug: String "Revision number for collection.\n        If null, will return the latest published revision for this collection" revision: Int "Overrides adult content in user preferences" viewAdultContent: Boolean "Specifies game domain. Will return a NOT_FOUND\n response if invalid domain is passed." domainName: String): CollectionRevision!
  "Get a pre-signed upload URL for B2"
  collectionRevisionUploadUrl: PresignedUrl!
  "Get a list of collections"
  collections("Overrides adult content in user preferences" viewAdultContent: Boolean "Shows unlisted collections (permission required)" viewUnlisted: Boolean "Shows listed collections" viewListed: Boolean "Shows moderated collections (permission required)" viewUnderModeration: Boolean "Shows discarded collections (permission required)" viewDiscarded: Boolean "Filter which restricts results and facets." filter: CollectionsSearchFilter "Filter which restricts results but not facets." postFilter: CollectionsSearchFilter sort: [CollectionsSearchSort!] "Filter and aggregate by specified facets." facets: CollectionsFacet offset: Int count: Int): CollectionPage!
  "Get a comment by its ID."
  comment("The database ID for this comment." commentId: ID!): Comment!
  "Get a comment thread by its ID."
  commentThread("The database ID for this comment thread." commentThreadId: ID!): CommentThread!
  "Gets an external video."
  externalVideo("The external video URL." url: String!): ExternalVideo!
  "Gets a user's favourite games"
  favouriteGames: [Game!]
  "Get Mod FileHash by md5"
  fileHash("MD5 file hashes for retrieving files" md5: String!): [FileHash!]!
  "Get a list of FileHashes"
  fileHashes("Array of MD5 file hashes for retrieving files in bulk" md5s: [String!]!): [FileHash!]
  "Get a Game by ID or domain name"
  game("Game ID to retrieve game for" id: ID "Game domain name to retrieve game for" domainName: String): Game
  "Get a list of Games"
  games("Filter and aggregate by specified facets" facets: GamesFacet "Filter which restricts results and facets." filter: GamesSearchFilter "Filter which restricts results but not facets." postFilter: GamesSearchFilter sort: [GamesSearchSort!] offset: Int count: Int): GamePage!
  "Get a list of the current user's blocked authors."
  legacyBlockedAuthors: [User!] @deprecated(reason: "This is a legacy endpoint and should not be used.")
  "Get a list of mod using composite ids, with paging"
  legacyMods("Mod ID (Legacy format)" ids: [CompositeIdInput!]! offset: Int count: Int): ModPage!
  "Get a list of mods by domain_name and id, with paging"
  legacyModsByDomain("Get mod by legacy ID format" ids: [CompositeDomainWithIdInput!]! offset: Int count: Int): ModPage!
  "Gets the actions logs related to a mod for a given user and game"
  modActions("The user we are getting the logs for" userId: Int! "(Optional) The game we are getting the logs for" gameId: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ActionLogConnection!
  "Get a list of users that have endorsed a mod. Will return a maximum of 100 items per page."
  modEndorsers("Mod UID to retrieve endorsers for" modUid: ID! "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ModEndorserConnection!
  "Get a list of mod files"
  modFiles("Mod ID for retrieving mods in bulk" modId: ID! "Game ID for retrieving mods in bulk" gameId: ID!): [ModFile!]!
  "Get a list of mod files by uid"
  modFilesByUid("List of Mod File UIDs (Not IDs) for retreiving mods in bulk" uids: [ID!]! offset: Int count: Int): ModFilePage!
  "Get a Moderation Reason by ID"
  moderationReason("The database ID for this moderation reason." id: ID!): ModerationReason
  "Get a list of Moderation Reasons"
  moderationReasons: [ModerationReason!]
  "Get a list of mods, with paging"
  mods("View published mods (default: true)" viewPublished: Boolean "View not published mods (permission check applied,\n                  must be uploader, admin or moderator)" viewNotPublished: Boolean "View mods that will be published when game approved\n                  (permission check applied, must be uploader, admin or moderator)" viewPublishWithGame: Boolean "View mods under moderation (permission check applied,\n                  must be uploader, admin or moderator)" viewUnderModeration: Boolean "View removed mods (permission check applied, must be uploader, admin or moderator)" viewRemoved: Boolean "View hidden mods (permission check applied, must be uploader, admin or moderator)" viewHidden: Boolean "Filter and aggregate by specified facets" facets: ModsFacet filter: ModsFilter postFilter: ModsFilter sort: [ModsSort!] offset: Int count: Int): ModPage!
  "Get a list of mods by uid, with paging"
  modsByUid("List of Mod UIDs (Not IDs) for retreiving mods in bulk" uids: [ID!]! offset: Int count: Int): ModPage!
  "Get a list of collections that the current user has access to view"
  myCollections("Include specified aggregations in the results" aggregations: [CollectionAggregate!] "Filter and aggregate by specified facets" facets: CollectionsFacet "Alters the sorting column used for this query" sortBy: String "Alters the sorting direction used for this query" sortDirection: String "Overrides adult content in user preferences" viewAdultContent: Boolean "Shows unlisted collections (permission required)" viewUnlisted: Boolean "Shows moderated collections (permission required)" viewUnderModeration: Boolean "Filters the collections to a specific game." gameDomain: String "Filters the collections to a specific game." gameId: Int "Filters the collections to a specific category." categoryId: Int "Filter which restricts results and facets." filter: CollectionsFilter "Filter which restricts results but not facets." postFilter: CollectionsFilter offset: Int count: Int): CollectionPage!
  "retrieves all news articles."
  news("Filters the News to a specific news category." newsCategory: NewsCategoryEnum "Filters the News to a specific game." gameId: Int offset: Int count: Int): NewsPage!
  "Get a list of opted in mods for this user"
  optedInMods("ID of account for filtering" accountId: Int!): OptedInMods!
  "Gets the log showing the latest time when the user changed their paypal email"
  paypalEmailLastChanged("The user we are getting this event for" userId: Int! "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ActionLogConnection!
  "Get a private message URL"
  privateMessageUrl("Nexusmods ID of user to message" id: ID!): String
  "Get a pre-signed upload URL. You must supply EITHER mimeType (preferred) or filename."
  requestMediaUploadUrl("Local filename of the file to be uploaded. DEPRECATED- prefer mimeType." filename: String "MIME type of the file to be uploaded." mimeType: String): PresignedUrl!
  "Search comments by filter and sort criteria"
  searchComments(filter: CommentsSearchFilter sort: [CommentsSearchSort!] "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentSearchResultConnection!
  "Get the urls for running a speedtest to diagnose download issues"
  speedtestUrls: [SpeedtestUrl!]!
  "Get the actions logs for content the specified user is subscribed to"
  subscriptionActions("The user we are getting the logs for" userId: Int! "(Optional) The game we are getting the logs for" gameId: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): SubscriberActionsUnionConnection!
  "Get a tag by ID"
  tag("ID of Tag Category to find" id: ID!): Tag
  "Get all tag categories"
  tagCategories: [TagCategory!]
  "Get a tag category by ID"
  tagCategory("ID of Tag Category to find" id: ID!): TagCategory
  "Get a list of tags"
  tags("Filter tags by a specific game ID" gameId: Int "Filter tags by a specific category ID" categoryId: Int "If true, will include all global tags" includeGlobal: Boolean "If true, will includes discarded tags" includeDiscarded: Boolean): [Tag!]
  "Get a list of transactions, with paging and filtering"
  transactions("Offset for pagination" start: Int "Number of elements to return per\npage" perPage: Int "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String "Column used for sorting" orderColumn: String "Includes transactions involving this\nAccount's ID" accountId: Int "Includes transactions involving this\nBank's ID" bankId: Int "Filter transactions to return" search: String): TransactionList!
  "Get the count of unread messages for a user."
  unreadMessageCount: Int!
  "Get a list of uploads"
  uploads("For offset-based pagination. Indicates\nthe first element to start returning values from" start: Int! "Number of elements to return per\npage" perPage: Int! "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String! "Column used for sorting" orderColumn: String! "The database ID for this ModUpload." id: String "Filter uploads" search: String "Filter uploads" filter: String "Only return specific types of uploads" uploadType: String "The database ID for this Game." gameId: Int "The database ID for this User." userId: Int "The database ID for this ModFile." fileId: Int "The database ID for this Mod." modId: Int): UploadList!
  "Get user by id"
  user("User ID of user to find" id: Int!): User!
  "Gets relevant action log entries for a user"
  userActions("The user whose actions we are getting" userId: Int! "(Optional) game to get actions for" gameId: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ActionLogConnection!
  "Get user by username"
  userByName("Username of user to find" name: String!): User!
  "Get monthly summary report for a specific user"
  userMonthlyReport("Account ID" accountId: Int! "Year report was generated" year: Int! "Month report was generated" month: Int!): UserMonthlyReport!
  "Get a specific report for a specific user"
  userMonthlyReportById("Account ID" accountId: Int! "Donation Report ID" reportId: Int!): UserMonthlyReport!
  "Get monthly summary report for a specific user"
  userMonthlySummary("Account ID" accountId: Int!): UserMonthlySummary!
  "Get a list of wallets, with paging and filtering"
  wallets("For offset-based pagination. Indicates\nthe first element to start returning values from" start: Int "Number of elements to return per\npage" perPage: Int "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String "Column used for sorting" orderColumn: String "Used to filter specific accounts" search: String): WalletList! @deprecated(reason: "Legacy Query. This endpoint may change or become unstable in future updates.")
}

input RandomSortValue {
  "If passed, randomness will be deterministic"
  seed: Int
}

"Ratable Model Types"
enum Ratable {
  "A nexusmods Collection of Mods"
  CollectionRevision
  "A Nexusmods Mod"
  Mod
}

"A Rating"
type Rating implements Node {
  "ID of the object."
  id: ID!
  "Polymorphic ID of the entity being rated"
  modelId: Int!
  "Polymorphic type of the entity being\nrated"
  modelType: String!
  "Rating value"
  rating: String!
  "ID of the user that created this rating"
  userId: Int!
}

"Rating options"
enum RatingOptions {
  positive
  negative
  abstained
}

"Autogenerated return type of RejectModerationFixMutation."
type RejectModerationFixMutationPayload {
  "Return the moderation fix object"
  moderationFix: ModerationFix!
  "Returns trus if the fix was rejected"
  success: Boolean!
}

"Autogenerated return type of RemoveCommentLikeMutation."
type RemoveCommentLikeMutationPayload {
  "The comment that had its like removed."
  comment: Comment!
}

"Autogenerated return type of RemoveFavouriteGameMutation."
type RemoveFavouriteGameMutationPayload {
  "True if the favourite was successfully removed"
  success: Boolean!
}

"Autogenerated return type of RemoveHeaderImageFromCollectionMutation."
type RemoveHeaderImageFromCollectionMutationPayload {
  "Returns true when image was removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveImageFromCollectionMutation."
type RemoveImageFromCollectionMutationPayload {
  "Returns true when image is removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveKudosMutation."
type RemoveKudosMutationPayload {
  "True if the user has successfully had kudos removed"
  success: Boolean!
}

"Autogenerated return type of RemoveTagFromCollectionMutation."
type RemoveTagFromCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of RemoveTileImageFromCollectionMutation."
type RemoveTileImageFromCollectionMutationPayload {
  "Returns true when image is removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveVideoFromCollectionMutation."
type RemoveVideoFromCollectionMutationPayload {
  "Returns true when video is removed successfully."
  success: Boolean!
}

"Autogenerated return type of ReorderItem."
type ReorderItemPayload {
  "The item that was moved."
  item: Reorderable
}

"The relative location of an item in relation to another item."
enum ReorderLocation {
  "Before the item."
  BEFORE
  "After the item."
  AFTER
}

"Autogenerated return type of ReorderPinnedCommentsMutation."
type ReorderPinnedCommentsMutationPayload {
  "Pinned comments in a new order."
  comments: [Comment!]!
}

"A reorderable entity."
interface Reorderable {
  "The order of this entity in the list."
  order: String!
}

"Autogenerated return type of ReportCollectionBugReportMutation."
type ReportCollectionBugReportMutationPayload {
  "True if the report was created"
  success: Boolean
}

"Autogenerated return type of ReportCollectionMutation."
type ReportCollectionMutationPayload {
  "Success Boolean"
  success: Boolean
}

"Autogenerated return type of ReportCommentMutation."
type ReportCommentMutationPayload {
  "The comment that was reported."
  report: CommentReport!
}

"Autogenerated return type of RestoreCommentMutation."
type RestoreCommentMutationPayload {
  "The comment that was restored."
  comment: Comment!
}

"Autogenerated return type of RetractRevisionMutation."
type RetractRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"A reason for which a revision has been retracted."
type RetractionReason {
  "An immutable revision of a collection"
  collectionRevisionId: Int!
  "Time of when this retraction reason was first created."
  createdAt: DateTime!
  "The database ID for this retraction reason."
  id: Int!
  "User-provided reason for this retraction"
  reason: String!
  "Time of when this retraction reason was last updated."
  updatedAt: DateTime!
}

"Sort directions: ASC, DESC"
enum SortDirection {
  "Ascending"
  ASC
  "Descending"
  DESC
}

"A speedtest URL"
type SpeedtestUrl {
  "Description of this speedtest URL"
  description: String
  "URL of the resource"
  location: String
  "Tag of the resource"
  tag: String
  "Resource name of this speedtest URL"
  title: String
}

"Autogenerated return type of SubmitModerationFixMutation."
type SubmitModerationFixMutationPayload {
  "Return moderation fix object"
  moderationFix: ModerationFix!
  "Returns true if this fix was created successfully"
  success: Boolean!
}

"Activity which can appear in a user's activity feed"
union SubscriberActionsUnion = ActionLog | ForumPost

"The connection type for SubscriberActionsUnion."
type SubscriberActionsUnionConnection {
  "A list of edges."
  edges: [SubscriberActionsUnionEdge]
  "A list of nodes."
  nodes: [SubscriberActionsUnion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type SubscriberActionsUnionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SubscriberActionsUnion
}

"The definition of a Tag Object. Deprecated.\nWill be removed in a future release in favour of domain specific tag queries\/mutations"
type Tag {
  "If true, this Tag is intended for adult content"
  adult: Boolean!
  "Category that this tag belongs to"
  category: TagCategory
  "Time of when this tag was first created."
  createdAt: DateTime!
  "Time of when this tag was discarded."
  discardedAt: DateTime
  "List of games that this tag is for"
  games: [Game!]
  "If true, this Tag is global and not intended for a specific game"
  global: Boolean!
  "The database ID for this tag."
  id: ID!
  "Name of this tag"
  name: String!
  "Number of tagged entities for this tag"
  taggablesCount: Int!
  "Time of when this tag was last updated."
  updatedAt: DateTime!
}

"The definition of a Tag Category Object. Deprecated.\nWill be removed in a future release in favour of domain specific tag queries\/mutations"
type TagCategory {
  "Time of when this tag category was first created."
  createdAt: DateTime!
  "Time of when this tag category was discarded."
  discardedAt: DateTime
  "The database ID for this tag category."
  id: ID!
  "Name of this Tag Category"
  name: String!
  "List of tags in this catgeory"
  tags: [Tag!]
  "Time of when this tag category was last updated."
  updatedAt: DateTime!
}

"Accepted Thumbnail Sizes"
enum ThumbnailSize {
  "250px width"
  small
  "385px width"
  med
  "500px width"
  large
}

"Autogenerated return type of TrackUserMutation."
type TrackUserMutationPayload {
  "True if the request to track the user was successful"
  success: Boolean!
}

"A transaction"
type Transaction {
  "Amount of DP in this transaction"
  amount: Int!
  "Time of when this transaction was first created."
  createdAt: String!
  "Account\/Bank that DP is being sent to"
  creditor: String @deprecated(reason: "Use 'creditorEntity' instead")
  "Account\/Bank that DP is being sent to"
  creditorEntity: PaymentEntity
  "Account\/Bank that DP is being taken from"
  debitor: String @deprecated(reason: "Use 'debitorEntity' instead")
  "Account\/Bank that DP is being taken from"
  debitorEntity: PaymentEntity
  "The database ID for this transaction."
  id: Int!
  "Descriptive label for this transaction"
  label: String!
  "Type of transaction E.g. 'refund', 'purchase' etc"
  type: String!
}

"A list of transactions"
type TransactionList {
  "Number of transactions being filtered"
  filteredCount: Int!
  "Total number of transactions in the system"
  totalCount: Int!
  "List of Transactions"
  transactions: [Transaction!]
}

"Autogenerated return type of UnlistCollectionMutation."
type UnlistCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of UnpinCommentMutation."
type UnpinCommentMutationPayload {
  "The comment that was unpinned."
  comment: Comment!
}

"Autogenerated return type of UntrackUserMutation."
type UntrackUserMutationPayload {
  "True if the request to stop tracking the user was successful"
  success: Boolean!
}

"Autogenerated return type of UpdateAboutMeMutation."
type UpdateAboutMeMutationPayload {
  "True if the bio was successfully updated"
  success: Boolean!
}

"Autogenerated return type of UpdateChangelogMutation."
type UpdateChangelogMutationPayload {
  "Updated Changelog ID"
  changelogId: Int!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of UpdateCollectionBugReportMutation."
type UpdateCollectionBugReportMutationPayload {
  "Collection bug report that was updated"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of UpdateCommentMutation."
type UpdateCommentMutationPayload {
  "The comment that was updated."
  comment: Comment!
}

"Autogenerated return type of UpdateCountryMutation."
type UpdateCountryMutationPayload {
  "True if the country was successfully updated"
  success: Boolean!
}

"Defines a Image Update request object"
input UpdateImageInput {
  "Image ID"
  id: ID!
  "Image title"
  title: String
  "Alternative text"
  altText: String
}

"Available update policies of a file resource"
enum UpdatePolicy {
  "Use the exact specified version"
  exact
  "Use the latest version"
  latest
  "Prefer the specified version if available"
  prefer
}

"Autogenerated return type of UpdateRevisionMutation."
type UpdateRevisionMutationPayload {
  "The revision ID that was updated"
  revisionId: Int!
  "If true, the revision was updated"
  success: Boolean!
}

"Autogenerated return type of UpdateTagMutation."
type UpdateTagMutationPayload {
  "Success Boolean"
  success: Boolean!
  "Updated Collection Tag"
  tag: Tag!
}

scalar Upload

"Autogenerated return type of UploadAttachmentMutation."
type UploadAttachmentMutationPayload {
  "The uploaded file returns a signed_id that can be used to attach to objects."
  attachment: Attachment!
}

"Defines a Image Upload request object"
input UploadImageInput {
  "Image UUID"
  id: ID!
  "Image content type"
  contentType: String!
  "Image title"
  title: String
  "Alternative text of the image"
  altText: String
}

"A list of upload"
type UploadList {
  "Number of uploads being filtered"
  filteredCount: Int!
  "Total number of uploads"
  totalCount: Int!
  "List of uploads"
  uploads: [ModUpload!]
}

"Defines a Video Upload request object"
input UploadVideoInput {
  "Video URL"
  url: String!
}

"A Nexus Mods user"
type User {
  "User's bio"
  about: String
  "The avatar for this user"
  avatar: String!
  "If true, this user has been banned"
  banned: Boolean!
  "Number of collections uploaded by this user.\nThis does not include unlisted or moderated collections."
  collectionCount: Int!
  "ISO Country Code"
  country: String
  "If true, this user has been deleted"
  deleted: Boolean!
  "If true, this user has enabled donations on their profile page"
  donationsEnabled: Boolean!
  "If false, this user has specifically opted-out of the DP system. By default, all users are opted in."
  dpOptedIn: Boolean!
  "The user's email address. Users can only access their own protected data."
  email: String!
  "Number of mod endorsements given by this user"
  endorsementsGiven: Int!
  "The number of full page notifications this user has been served in the past."
  fullPageNotificationCount: Int
  "If true, the viewer (current user) has\ngiven kudos to this user."
  hasGivenKudos: Boolean!
  "Number of images uploaded by this user.\nThis does not include moderated images."
  imageCount: Int!
  "The user's last known IP Address. Users can only access their own protected data."
  ipAddress: String
  "If true, the viewer (current user) has\nblocked this user."
  isBlocked: Boolean!
  "If true, the viewer (current user) is\ntracking this user."
  isTracked: Boolean!
  "Date the user joined"
  joined: DateTime!
  "The number of 'kudos' given to this user"
  kudos: Int!
  "Date the user was last active"
  lastActive: DateTime
  "Legacy roles for this user. Returns an array of roles. E.g. \"[SiteProgrammer, QA Tester]\""
  legacyRoles: [String!]!
  "The database ID for this user."
  memberId: Int!
  "Membership status for this user. Returns an array of roles. E.g. all users are \"member\""
  membershipRoles: [String!]!
  "Number of mods uploaded by this user.\nThis does not include hidden, moderated or unpublished mods."
  modCount: Int!
  "The number of moderation warnings this user has been served in the past."
  moderationHistoryCount: Int
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "The user's username."
  name: String!
  "Email address used for PayPal donations. Users can only access their own protected data."
  paypal: String
  "The number of forum posts by this user"
  posts: Int!
  "If true, this user is a\nrecognised mod author"
  recognizedAuthor: Boolean!
  "Roles for this user. Returns an array of roles. E.g. \"[Admin, Moderator]\""
  roles: [String!]!
  "If true, this user has opted to\nshow their activity feed on their user profile page"
  showActivityFeed: Boolean!
  "If true, this user has opted to\nshow the date they were last active on their user profile page"
  showLastActive: Boolean!
  "Number of unique mod downloads on this users mods"
  uniqueModDownloads: Int!
  "Date the user last\nchanged their username. Only users can access their own protected data."
  usernameLastChangedAt: DateTime
  "Number of videos uploaded by this user.\nThis does not include moderated videos."
  videoCount: Int!
  "Number of profile views"
  views: Int!
}

"The connection type for User."
type UserConnection {
  "A list of edges."
  edges: [UserEdge]
  "A list of nodes."
  nodes: [User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User
}

"Monthly detailed report for for a particular user\/account\n    on how much DP\/downloads they have received for which mod\/game"
type UserMonthlyReport {
  "List of entries in this report"
  entries: [UserMonthlyReportEntry!]!
  "A Nexus Mods user"
  user: User
  "The database ID for this user."
  userId: Int!
}

"A more detailed entry for UserMonthlyReport, with a breakdown for a specific month for each mod"
type UserMonthlyReportEntry {
  "A Nexus Mods user"
  author: User
  "Number of authors that give this user DP"
  authorCount: Int
  "The database ID for this user."
  authorId: Int
  "Total DP value from all authors this user gets DP from, including DP not shared with this user."
  authorValue: Int
  "A Game"
  game: Game
  "The database ID for this game."
  gameId: Int
  "A mod"
  mod: Mod
  "Number of mods that this user appears in"
  modCount: Int
  "The database ID for this mod."
  modId: Int
  "Total DP value from all mods this user appears in, including DP not shared with this user."
  modValue: Int
  "Month that this entry is for"
  month: Int!
  "Ratio of how much of the DP earned for a mod or author is given to this user"
  ratio: Float!
  "The database ID for this donation report."
  reportId: Int!
  "Opt-in status of this mod"
  status: Int!
  "Total DP granted to this user in this entry"
  value: Int!
  "Year that this entry is for"
  year: Int!
}

"Monthly summary for for a particular user\/account on how much DP\/downloads they have received"
type UserMonthlySummary {
  "List of summary report entries for this month"
  entries: [UserMonthlySummaryEntry!]!
  "A Nexus Mods user"
  user: User!
  "The database ID for this user."
  userId: Int!
}

"An entry for UserMonthlySummary, with a breakdown for a specific month"
type UserMonthlySummaryEntry {
  "Number of mods that this user appears in"
  modCount: Int!
  "Total DP value from all mods this user appears in, including DP not shared with this user."
  modValue: Int!
  "Month that this entry is for"
  month: Int!
  "Total DP granted to this user in this entry"
  value: Int!
  "Year that this entry is for"
  year: Int!
}

"Records the outcome of the virus scan for a mod file."
enum VirusScanStatus {
  NOT_SCANNED
  QUEUED
  WAITING_REPORT
  VERIFIED
  INTERNALLY_VERIFIED
  QUARANTINED
  MANUALLY_VERIFIED
  MOD_DOES_NOT_EXIST
  FILE_NOT_FOUND
  REPORT_ERROR
  TOO_LARGE
}

"A list of wallets. Users must have admin access."
type WalletList {
  "Number of wallets being filtered"
  filteredCount: Int!
  "Total number of wallets in the system"
  totalCount: Int!
}

"Autogenerated return type of WriteFullPageNotificationToUserMutation."
type WriteFullPageNotificationToUserMutationPayload {
  "Full page notification created successfully"
  success: Boolean
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT