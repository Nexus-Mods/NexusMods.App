# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT

"Something that can have files attached to it"
interface Attachable {
    "The attachment filename and IDs"
    attachments: [Attachment!]
}

"A globally identifiable entity."
interface GloballyIdentifiable {
    "The global ID for this entity."
    globalId: ID
    "ID of the object."
    id: ID!
}

"An object with an ID."
interface Node {
    "ID of the object."
    id: ID!
}

"A reorderable entity."
interface Reorderable {
    "The order of this entity in the list."
    order: String!
}

"Collection Media"
union CollectionMediaUnion = CollectionImage | CollectionVideo

"Legacy Media Union"
union MediaUnion = Image | SupporterImage | Video

"Autogenerated return type of AbstainFromModEndorsementMutation."
type AbstainFromModEndorsementMutationPayload {
    "Endorsement entry."
    endorsement: ModEndorsement!
    "Returns true when abstaining was successful."
    success: Boolean!
}

"Autogenerated return type of AcceptModerationFixMutation."
type AcceptModerationFixMutationPayload {
    "Return the moderation fix"
    moderationFix: ModerationFix!
    "Returns true if the fix was accepted successfully"
    success: Boolean!
}

"Autogenerated return type of AddFavouriteGameMutation."
type AddFavouriteGameMutationPayload {
    "True if the favourite was successfully created"
    success: Boolean!
}

"Autogenerated return type of AddHeaderImageToCollectionMutation."
type AddHeaderImageToCollectionMutationPayload {
    "Header image that was added to the collection"
    image: CollectionImage!
}

"Autogenerated return type of AddImageToCollectionMutation."
type AddImageToCollectionMutationPayload {
    "Image that was added to the collection"
    image: CollectionImage!
}

"Autogenerated return type of AddTagToCollectionMutation."
type AddTagToCollectionMutationPayload {
    "True if all tags were added to the collection"
    success: Boolean!
}

"Autogenerated return type of AddTileImageToCollectionMutation."
type AddTileImageToCollectionMutationPayload {
    "Tile image that was added to the collection"
    image: CollectionImage!
}

"Autogenerated return type of AddVideoToCollectionMutation."
type AddVideoToCollectionMutationPayload {
    "Video that was added to the collection"
    video: CollectionVideo!
}

"Autogenerated return type of AmendModerationMutation."
type AmendModerationMutationPayload {
    "Return Types::Objects::Moderation::ModerationType"
    moderation: Moderation!
    "Boolean determining success or failure of the request."
    success: Boolean!
}

"A modding application (or \"integration\") accessed with an API key"
type ApiApplication {
    "If true, this application is active"
    active: Boolean!
    "Application ID"
    id: ID!
    "Application image URL"
    image: String!
    "The API key for the logged in user, if one exists"
    key: String
    "Application name"
    name: String!
    "Machine-readable application name"
    slug: String!
    "Application summary"
    summary: String!
}

"An API key for a modding application (or \"integration\")"
type ApiKey implements Node {
    "The application which this key is for"
    applicationId: ID
    "ID of the object."
    id: ID!
    "The API key itself"
    key: String!
    "The user whose key this is"
    userId: Int!
}

"Artwork schema using one tile image, additionally blurred for background use."
type ArtworkSchemaV1 {
    "URI template for primary game image."
    tile: String!
    "URI template for blurred image e.g. for background use."
    tileBlurred: String!
}

"Artwork schema introduced in May 2025, comprising tile, hero, and thumbnail images."
type ArtworkSchemaV2 {
    "URI template for hero e.g. for backgrounds, minimum 1920x620."
    hero: String!
    "URI template for thumbnail e.g. for icons, minimum 80x80."
    thumbnail: String!
    "URI template for tile e.g. for listings, minimum 400x267."
    tile: String!
}

"Type that exposes the attachment urls"
type Attachment implements Node {
    "The attachment filename"
    filename: String!
    """

    A unique ID for this attachment. This is a signed ID that will change between requests. This
    is expected behaviour and is to avoid tampering.
    """
    id: ID!
    "The attachment URL"
    url: String!
}

"Average rating for a single revision and total number of votes"
type AverageRating {
    "Average rating for this revision"
    average: Float!
    "Number of positive votes"
    positive: Int!
    "Total number of votes"
    total: Int!
}

"Autogenerated return type of BlockModsFromEarningDpMutation."
type BlockModsFromEarningDpMutationPayload {
    "True if the mods were successfully blocked"
    success: Boolean!
}

"Autogenerated return type of BlockTagMutation."
type BlockTagMutationPayload {
    "If true, the tag is blocked."
    success: Boolean!
}

"Autogenerated return type of BlockUserMutation."
type BlockUserMutationPayload {
    "If true, the user is blocked."
    success: Boolean!
}

"A mod blocked from earning donation points"
type BlockedMod {
    "The database ID for this blocked_mod."
    id: String!
    "True if the mod is blocked from earning donation points"
    isBlocked: Boolean!
}

"A page of data"
type BlockedModsPage {
    "A list of entries"
    nodes: [BlockedMod!]!
    "Information about the page"
    pageInfo: BlockedModsPageInfo!
}

"Information about a page"
type BlockedModsPageInfo {
    "The total number of entries"
    totalCount: Int!
}

"A category into which related entities may fall"
type Category {
    "Whether the category has been approved"
    approved: Boolean!
    "The id of the user who approved the category"
    approvedBy: Int
    "A list of games for which this category is used"
    categoryGames: [Game!]
    "Time of when this category was first created."
    createdAt: DateTime!
    "A brief description of the category's purpose"
    description: String!
    "Time of when this category was discarded."
    discardedAt: DateTime
    "The database ID for this category."
    id: Int!
    "The name of the category"
    name: String!
    "The id of the parent category"
    parentId: Int!
    "The id of the user who suggested the category"
    suggestedBy: Int!
    "Time of when this category was last updated."
    updatedAt: DateTime!
}

"Autogenerated return type of ChangeCollectionOwner."
type ChangeCollectionOwnerPayload {
    "Updated collection"
    collection: Collection!
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of ClearCollectionBugReportModerationStatusMutation."
type ClearCollectionBugReportModerationStatusMutationPayload {
    "Collection bug report whose status was cleared"
    collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of ClearCommentModerationStatusMutation."
type ClearCommentModerationStatusMutationPayload {
    "The comment that had its moderation status cleared."
    comment: Comment!
}

"Autogenerated return type of ClearThreadModerationStatusMutation."
type ClearThreadModerationStatusMutationPayload {
    "The comment thread that had its moderation status cleared."
    commentThread: CommentThread!
}

"Autogenerated return type of CloseCollectionBugReportMutation."
type CloseCollectionBugReportMutationPayload {
    "Collection bug report which was closed"
    collectionBugReport: CollectionBugReport!
}

"A curated collection of mods"
type Collection {
    "Indicates whether the collection contains adult content"
    adultContent: Boolean @deprecated(reason: "Adult content is now indicated at the revision level")
    "Whether to allow non-curator users to upload media"
    allowUserMedia: Boolean
    "Fetch a bug report for this collection by its id"
    bugReport(
        "The database ID for this bug report."
        bugReportId: ID!
    ): CollectionBugReport!
    "A list of bug reports raised for the collection"
    bugReports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Column for sorting bug reports"
        sortBy: String,
        "Direction for sorting bug reports"
        sortDirection: String,
        "Filter bug reports by status. Possible opens are \"Open\" or \"Closed\""
        status: BugReportStatus!
    ): CollectionBugReportConnection!
    "A category into which related entities may fall"
    category: Category
    "A list of changelogs created for the revisions of this collection"
    collectionChangelogs: [CollectionChangelog!]
    "Available collection statuses"
    collectionStatus: CollectionStatus
    "A link to the forum thread containing comments"
    commentLink: String
    "The comment thread for this collection."
    commentThread: CommentThread!
    "Time of when this collection was first created."
    createdAt: DateTime!
    "Latest published revision"
    currentRevision(
        "Revision number"
        revision: Int
    ): CollectionRevision! @deprecated(reason: "Deprecated in favour of using a 'collectionRevision' query")
    "A description of the collection in Markdown format"
    description: String!
    "A reason why the collection was discarded"
    discardReason: CollectionDiscardReason
    "Time of when this collection was discarded."
    discardedAt: DateTime
    "A link to download the collection"
    downloadLink: String!
    """

    If there is a draft revision in this collection, this will return the revisionNumber
    for that revision. If there are no draft revisions, this will simply be null
    """
    draftRevisionNumber: Int
    "The number of endorsements given to the collection"
    endorsements: Int!
    """

    Time of when the first of this collection's revisions
    was first published
    """
    firstPublishedAt: DateTime
    "The forum topic created to hold comments for this collection"
    forumTopic: ForumTopic @deprecated(reason: "Use `commentThread` instead.")
    "The game for which the collection was created"
    game: Game!
    "The id of the game for which the collection was created"
    gameId: Int!
    "The image used as the background of the header on the collection's page"
    headerImage: CollectionImage
    "The database ID for this collection."
    id: Int!
    """

    Time of when one of this collection's revisions
    was last published
    """
    lastPublishedAt: DateTime
    """

    The latest published revision for this collection. This will be
    null for collections with no published revisions
    """
    latestPublishedRevision: CollectionRevision
    "Rating of the latest published revision"
    latestPublishedRevisionRating: String
    "Time of when this collection was first listed"
    listedAt: DateTime
    "Whether uploaded media requires verification before being displayed"
    manuallyVerifyMedia: Boolean
    "A list of media uploaded to the collection, including images and videos"
    media: [CollectionMediaUnion!]!
    "Metadata information about a collection"
    metadata: CollectionMetadata
    "JWT token for submitting moderation reports"
    moderationJwt: String!
    "A list of moderation actions taken against this collection"
    moderations: [Moderation!]
    "The collection name"
    name: String!
    "An average taken from all revision ratings"
    overallRating: String
    "Total number of ratings given across all revisions"
    overallRatingCount: Int
    "The list of permissions granted to the requesting user against this collection."
    permissions: [Permission!]
    "Returns \"sanitized\" collection revisions. Safe to use with discarded revisions."
    publicRevisions: [PublicCollectionRevision!]
    """

    Time of when one of this collection's revisions
    was last published
    """
    publishedAt: DateTime @deprecated(reason: "Use `last_published_at` instead.")
    "A 30 day average of all revision ratings"
    recentRating: String
    "Total number of ratings given in the last 30 days"
    recentRatingCount: Int
    "A list of revisions for the collection"
    revisions: [CollectionRevision!]!
    """

    A random string of characters identifying the collection. This is the identifier used in
    a collection page url.
    """
    slug: String!
    "A brief summary of the collection"
    summary: String!
    "A list of tags attached to the collection, used to surface the collection in search results"
    tags: [Tag!]!
    "The image used to identify the collection in list views"
    tileImage: CollectionImage
    "The total number of times this collection has been downloaded"
    totalDownloads: Int!
    "The total number of unique users who have downloaded this collection"
    uniqueDownloads: Int!
    "Time of when this collection was last updated."
    updatedAt: DateTime!
    "The curating user"
    user: User!
    "The id of the collection curator"
    userId: Int!
    "Whether the viewer has ignored the content owner."
    viewerBlocked: Boolean! @deprecated(reason: "Use `viewerHasIgnored` instead.")
    "Whether the viewer has ignored the content owner."
    viewerHasIgnored: Boolean!
    "Whether the viewer is blocked by the content owner."
    viewerIsBlocked: Boolean
}

"A collection bug report."
type CollectionBugReport implements Attachable {
    "The attachment filename and IDs"
    attachments: [Attachment!]
    "Date that this report was changed to closed"
    closedAt: DateTime
    "If closed, what was the reason for closing the report"
    closureReason: BugReportClosureReason
    "A curated collection of mods"
    collection: Collection!
    "The collection revision number."
    collectionRevisionNumber: Int!
    "The comment thread for this collection bug report."
    commentThread: CommentThread!
    "Date that this report was created"
    createdAt: DateTime!
    "User-provided summary of the Bug Report"
    description: String
    "User that hid this Bug Report from public view"
    hiddenBy: User
    """

    If hidden, this will provide a reason. This is intended for moderators, admins and
    collection curators
    """
    hiddenInternalReason: String
    "If hidden, this will provide the reason"
    hiddenReason: String
    "The database ID for this collection bug report."
    id: ID!
    "JWT token for submitting moderation reports"
    moderationJwt: String!
    "If under moderation, can be none or hidden"
    moderationStatus: BugReportModerationStatus!
    "Date that this report was changed to open"
    openedAt: DateTime
    "Provides a list of all permissions for this report, using the context of the current user"
    permissions: [Permission!]
    "User that reported this Bug Report"
    reporter: User!
    "Status, can be Open or Closed"
    status: BugReportStatus!
    "Title of the bug report"
    title: String!
    "Date that this report was last updated"
    updatedAt: DateTime!
    "Whether the viewer has ignored the content owner."
    viewerHasIgnored: Boolean!
}

"The connection type for CollectionBugReport."
type CollectionBugReportConnection {
    "A list of edges."
    edges: [CollectionBugReportEdge]
    "A list of nodes."
    nodes: [CollectionBugReport]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type CollectionBugReportEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CollectionBugReport
}

"A changelog attached to a collection revision"
type CollectionChangelog {
    "The id of the collection revision for which this changelog was created"
    collectionRevisionId: Int!
    "Time of when this collection changelog was first created."
    createdAt: DateTime!
    "The content of the collection changelog, in Markdown format"
    description: String!
    "The database ID for this collection changelog."
    id: Int!
    "The revision number of the collection revision for which this changelog was created"
    revisionNumber: Int!
    "Time of when this collection changelog was last updated."
    updatedAt: DateTime!
}

"A reason for which a revision has been retracted."
type CollectionDiscardReason {
    "The id of the collection which was discarded"
    collectionId: Int!
    "Time of when this collection discard reason was first created."
    createdAt: DateTime!
    "The database ID for this collection discard reason."
    id: Int!
    "The reason why the collection was discarded"
    reason: String!
    "Time of when this collection discard reason was last updated."
    updatedAt: DateTime!
}

"Images related to a collection"
type CollectionImage implements GloballyIdentifiable & Reorderable {
    "The alt text describing the image for screen readers"
    altText: String
    "The collection for which the image was uploaded"
    collection: Collection!
    "Time of when this collection image was first created."
    createdAt: DateTime!
    "Time of when this collection image was discarded."
    discardedAt: DateTime
    "The global ID for this entity."
    globalId: ID
    "The database ID for this collection image."
    id: ID!
    "Determines where the image is displayed"
    imageType: ImageTypes!
    "The order of this entity in the list."
    order: String!
    "The collection revision for which the image was uploaded"
    revision: CollectionRevision
    "Can be used to select a scaled down/compressed version of the image"
    thumbnailUrl(
        "The thumbnail size"
        size: ThumbnailSize!
    ): String!
    "The image title"
    title: String
    "Time of when this collection image was last updated."
    updatedAt: DateTime!
    "The image resource url"
    url: String!
    "The user who uploaded the image"
    user: User!
}

"Metadata information about a collection"
type CollectionMetadata {
    "A timestamp indicating the first time the user downloaded this collection"
    downloadedAt: DateTime
    """

    A positive value indicates an endorsement by the user, while a negative value
    indicates abstention (will be null if the user has not endorsed the collection)
    """
    endorsementValue: Int
    "The latest revision number downloaded by the user for this collection"
    latestDownloadedRevisionNumber: Int
}

type CollectionPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [Collection!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"An immutable revision of a collection"
type CollectionRevision {
    "If true, this revision could contain adult content and needs to be treated accordingly"
    adultContent: Boolean!
    "The size of bundled assets within the revision in bytes"
    assetsSizeBytes: BigInt!
    "Gets the collection that this revision belongs to. This will ignore adult_content flags."
    collection: Collection!
    "A changelog attached to a collection revision"
    collectionChangelog: CollectionChangelog
    "The database ID for this collection."
    collectionId: Int!
    "A model of the expected structure for a collection manifest"
    collectionSchema: CollectionSchema!
    "The database ID for this collection schema."
    collectionSchemaId: Int!
    "The link to generate a content preview for the revision"
    contentPreviewLink: String!
    "Time of when this revision was first created."
    createdAt: DateTime!
    "Time of when this revision was discarded."
    discardedAt: DateTime
    "The download link for the revision"
    downloadLink: String!
    "Array of external resources referenced by this revision"
    externalResources: [ExternalResource!]!
    "The total size of the revision in bytes"
    fileSize: BigInt! @deprecated(reason: "Use \"totalSize\" instead.")
    """

    A list of game versions for which the revision has been confirmed to work (usually the
    game version for which the revision was created)
    """
    gameVersions: [GameVersion!]
    "The database ID for this revision."
    id: Int!
    "Additional information about the installation process of this revision"
    installationInfo: String
    "Will be true if the revision is the latest published for the collection"
    latest: Boolean!
    "Metadata information about a collection revision"
    metadata: CollectionRevisionMetadata
    """

    List of authors of the mods included in this revision ordered (DESC) by the number of
    mods in the revision.
    """
    modAuthors(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): UserConnection!
    "The number of mods and external resources in this collection"
    modCount: Int!
    "A list of mod files included in the revision"
    modFiles: [CollectionRevisionMod!]!
    "An average taken from all ratings for this revision"
    overallRating: String
    "A count of all ratings for this revision"
    overallRatingCount: Int
    "Average rating for a single revision and total number of votes"
    rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
    "A reason for which a revision has been retracted."
    retractionReason: RetractionReason
    "The revision number"
    revision: Int! @deprecated(reason: "Use \"revisionNumber\" instead.")
    "The revision number"
    revisionNumber: Int!
    "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
    revisionStatus: String!
    "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
    status: String!
    "The total number of times the revision has been downloaded"
    totalDownloads: Int!
    "The total size of the revision in bytes"
    totalSize: BigInt!
    "The number of unique users who have download the revision"
    uniqueDownloads: Int!
    "Time of when this revision was last updated."
    updatedAt: DateTime!
}

"Metadata information about a collection revision"
type CollectionRevisionMetadata {
    "A timestamp indicating the first time the user downloaded this revision"
    downloadedAt: DateTime
    "Indicates the rating given by the user to a revision"
    ratingValue: RatingOptions
}

"A mod file included in a collection"
type CollectionRevisionMod {
    "The id of the collection revision including the mod file"
    collectionRevisionId: Int!
    "The mod file"
    file: ModFile
    "The mod file's id"
    fileId: Int!
    "The game id for the mod file"
    gameId: Int!
    "The database ID for this collection revision mod."
    id: ID!
    "Whether the mod file is required for the collection"
    optional: Boolean!
    "Indicates to mod managers how they should handle automatic updates"
    updatePolicy: String!
    "The mod file version"
    version: String!
}

"A model of the expected structure for a collection manifest"
type CollectionSchema {
    "Time of when this collection schema was first created."
    createdAt: DateTime!
    "The database ID for this collection schema."
    id: Int!
    "Time of when this collection schema was last updated."
    updatedAt: DateTime!
    "Schema version for the collection manifest format"
    version: String!
}

"Videos related to a collection"
type CollectionVideo implements GloballyIdentifiable & Reorderable {
    "Collection that this video belongs to"
    collection: Collection!
    "Time of when this collection video was first created."
    createdAt: DateTime!
    "Time of when this collection video was discarded."
    discardedAt: DateTime
    "The global ID for this entity."
    globalId: ID
    "The database ID for this collection video."
    id: ID!
    "The order of this entity in the list."
    order: String!
    "Revision that this video belongs to"
    revision: CollectionRevision
    "The thumbnail URL for the video."
    thumbnailUrl: String!
    "The title of the video."
    title: String!
    "Time of when this collection video was last updated."
    updatedAt: DateTime!
    "URL of this video"
    url: String!
    "Uploader of this video"
    user: User!
}

"A comment."
type Comment implements Attachable {
    "The attachment filename and IDs"
    attachments: [Attachment!]
    "The content of the latest revision for this comment."
    body: String!
    "Time of when this comment was first created."
    createdAt: DateTime!
    "The user that created this comment."
    creator: User!
    "The pagination cursor for this comment."
    cursor: String!
    "Time of when this comment was discarded."
    discardedAt: DateTime
    "The user that discarded this comment."
    discardedBy: User
    "Time of when this comment was hidden."
    hiddenAt: DateTime
    "The user that hid this comment."
    hiddenBy: User
    "The internal reason why this comment was hidden. Only accessible to admins and moderators."
    hiddenInternalReason: String
    "The public reason why this comment was hidden."
    hiddenReason: String
    "The database ID for this comment."
    id: ID!
    "Returns a boolean indicating whether this comment is discarded."
    isDiscarded: Boolean!
    "Is this a pinned comment"
    isPinned: Boolean!
    "Comment likes count."
    likesCount: Int!
    "Time of when this comment was locked."
    lockedAt: DateTime
    "The user that locked this comment."
    lockedBy: User
    "Returns a boolean indicating whether this comment was moderated by an admin."
    moderatedByAdmin: Boolean!
    "JWT token for submitting moderation reports"
    moderationJwt: String!
    "The moderation status of this comment."
    moderationStatus: CommentModerationStatus!
    "The parent comment."
    parent: Comment
    "The user that pinned this comment."
    pinPriority: Int
    "User which pinned the comment"
    pinnedBy: User
    "Returns a boolean indicating whether this comment was pinned by an admin."
    pinnedByAdmin: Boolean!
    "A list of replies to this comment."
    replies(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): CommentConnection!
    "The revisions of this comment."
    revisions: [CommentRevision!]!
    "Time of when this comment was last updated."
    updatedAt: DateTime!
    "Whether the viewer has ignored the content owner."
    viewerHasIgnored: Boolean!
    "Returns a boolean indicating whether the viewing user has liked this comment."
    viewerHasLiked: Boolean!
}

"The connection type for Comment."
type CommentConnection {
    "A list of edges."
    edges: [CommentEdge]
    "A list of nodes."
    nodes: [Comment]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type CommentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Comment
}

"A comment revision."
type CommentRevision implements Node {
    "The content of this revision."
    body: String!
    "Time of when this revision was first created."
    createdAt: DateTime!
    "ID of the object."
    id: ID!
    "Time of when this revision was last updated."
    updatedAt: DateTime!
}

"The connection type for Comment."
type CommentSearchResultConnection {
    "A list of edges."
    edges: [CommentSearchResultEdge]
    "A list of nodes."
    nodes: [Comment]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Time taken to complete the search in milliseconds."
    timeTaken: Int!
    "Total number of results."
    totalCount: Int!
}

"A comment search result edge."
type CommentSearchResultEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Comment
    "The relevancy score of the result. Higher scores mean more relevance."
    relevance: Float!
}

"A comment thread."
type CommentThread {
    "Look up comments."
    comments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Sort results by"
        sortBy: String,
        "Sort direction"
        sortDirection: String
    ): CommentConnection!
    "The database ID for this comment thread."
    id: ID!
    "Time of when this comment thread was locked."
    lockedAt: DateTime
    "The user that locked this comment thread."
    lockedBy: User
    "Returns a boolean indicating whether this comment thread was moderated by an admin."
    moderatedByAdmin: Boolean!
    "The moderation status of this comment thread."
    moderationStatus: CommentThreadModerationStatus!
    "The thread owner"
    owner: User!
}

"Autogenerated return type of CreateApiKeyMutation."
type CreateApiKeyMutationPayload {
    "The created key"
    apiKey: ApiKey!
    "True if the key was successfully created"
    success: Boolean!
}

"Autogenerated return type of CreateChangelogMutation."
type CreateChangelogMutationPayload {
    "Updated changelog ID"
    changelogId: Int!
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of CreateCollectionBugReportMutation."
type CreateCollectionBugReportMutationPayload {
    "Collection bug report that was created"
    collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of CreateCollectionMutation."
type CreateCollectionMutationPayload {
    "Returns created collection"
    collection: Collection!
    "The database ID for this collection."
    collectionId: Int!
    "Returns the collection revision which is created alongside the collection"
    revision: CollectionRevision!
    "The database ID for this collection revision."
    revisionId: Int!
    "Returns true when collection is successfully created."
    success: Boolean!
}

"Autogenerated return type of CreateCommentMutation."
type CreateCommentMutationPayload {
    "The comment that was created."
    comment: Comment!
}

"Autogenerated return type of CreateEndorsementMutation."
type CreateEndorsementMutationPayload {
    "Endorsement entry."
    endorsement: Endorsement!
    "Returns true when endorsement is created successfully."
    success: Boolean!
}

"Autogenerated return type of CreateMessage."
type CreateMessagePayload {
    "Returns true when message was sent."
    success: Boolean!
}

"Autogenerated return type of CreateModEndorsementMutation."
type CreateModEndorsementMutationPayload {
    "Endorsement entry."
    endorsement: ModEndorsement!
    "Returns true when endorsement is created successfully."
    success: Boolean!
}

"Autogenerated return type of CreateNoteAboutUserMutation."
type CreateNoteAboutUserMutationPayload {
    "Moderation note created successfully"
    success: Boolean
}

"Autogenerated return type of CreateOrUpdateRevisionMutation."
type CreateOrUpdateRevisionMutationPayload {
    "Return the collection that was updated"
    collection: Collection!
    "The database ID for this collection."
    collectionId: Int!
    "Return the revision that was updated"
    revision: CollectionRevision!
    "The database ID for this revision."
    revisionId: Int!
    "The revision number"
    revisionNumber: Int!
    "Return true if the revision was updated"
    success: Boolean!
}

"Autogenerated return type of CreateRatingMutation."
type CreateRatingMutationPayload {
    "Average rating value of the entity the rating was created for."
    averageRating: AverageRating!
    "Rating entry."
    rating: Rating!
    "Returns true when rating is created successfully."
    success: Boolean!
}

"Autogenerated return type of CreateTagMutation."
type CreateTagMutationPayload {
    "Success Boolean"
    success: Boolean!
    "Created Tag"
    tag: Tag
}

"Autogenerated return type of DeleteApiKeyMutation."
type DeleteApiKeyMutationPayload {
    "Output message"
    message: String
    "True if the key was successfully removed"
    success: Boolean!
}

"Autogenerated return type of DeletePersonalApiKeyMutation."
type DeletePersonalApiKeyMutationPayload {
    "Output message"
    message: String
    "True if the key was successfully removed"
    success: Boolean!
}

"Autogenerated return type of DiscardCollectionMutation."
type DiscardCollectionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of DiscardCommentMutation."
type DiscardCommentMutationPayload {
    "The comment that was discarded."
    comment: Comment!
}

"Autogenerated return type of DiscardRevisionMutation."
type DiscardRevisionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of DiscardTagMutation."
type DiscardTagMutationPayload {
    "Returns true if tag was discarded"
    success: Boolean!
}

"Autogenerated return type of EditCollectionMutation."
type EditCollectionMutationPayload {
    "Return collection object"
    collection: Collection!
    "Returns true if collection was updated"
    success: Boolean!
}

"An Endorsement"
type Endorsement {
    "Id of endorsed entity"
    modelId: BigInt!
    "Type of endorsed entity"
    modelType: String!
    "Endorsement status: abstained/endorsed"
    status: String!
    "The database ID for this endorsement."
    userId: Int!
}

"A mod file that is not hosted on Nexus Mods"
type ExternalResource {
    """

    Similar to the author field in the mod details. So this is not
    the uploader and may not be an actual user account on the page. Will often be unassigned for external resources
    """
    author: String
    "The database ID for this revision."
    collectionRevisionId: Int!
    """

    Glob pattern that must then match the archive file name. In cases where the collection asks
    for a non-exact version (e.g.: 1.2.4 or newer) where we can't look at the hash of the expected file, this can be used
    to determine if the mod is already installed/downloaded locally.
    """
    fileExpression: String!
    "The database ID for this external resource."
    id: Int!
    "Deprecated"
    instructions: String @deprecated(reason: "This field is no longer being used")
    "Name of this resource"
    name: String!
    "If true, this is an optional resource"
    optional: Boolean!
    """

    Resource type. This can be one of "direct" (A url to
    download directly from), "browse" (A website url for the user to browse and manually select the right file on), "manual"
    (Vortex will just show instructions for the user to create/acquire the mod manually).
    """
    resourceType: String!
    """

    Only set in the "browse"/"direct" types, contains the url
    to browse to/download from
    """
    resourceUrl: String
    """

    The version of the mod that the curator had installed at the
    time of uploading the collection.
    """
    version: String
}

"An external video."
type ExternalVideo {
    "The embed URL for the video."
    embedUrl: String!
    "The external video ID."
    id: ID!
    "The platform where the video is hosted."
    platform: ExternalVideoPlatform!
    "The thumbnail URL for the video."
    thumbnailUrl: String!
    "The title of the video."
    title: String!
}

"A Mod File Hash"
type FileHash {
    "Time of when this file was first created."
    createdAt: DateTime!
    "Name of the file"
    fileName: String!
    "Filesize in bytes"
    fileSize: BigInt!
    "Type of file"
    fileType: String!
    "The database ID for this game."
    gameId: Int!
    "MD5 Checksum of the file"
    md5: String!
    "Mod file object"
    modFile: ModFile
    "The database ID for this file."
    modFileId: Int!
}

"A forum post"
type ForumPost {
    "Author ID of the forum post"
    authorId: Int!
    "Author name of the forum post"
    authorName: String!
    "The database ID for this forum post."
    id: Int!
    "Post contents"
    post: String!
    "Post date and time"
    postDate: Int!
    "Post author details"
    user: User!
}

"A forum topic"
type ForumTopic {
    "If true, this topic has been approved"
    approved: Boolean!
    "Description"
    description: String!
    "The database ID for this forum."
    forumId: Int!
    "The database ID for this forum topic."
    id: Int!
    """

    If true, this topic is pinned and should appear above all
    non-pinned topics
    """
    pinned: Boolean!
    "List of all posts within this topic"
    posts: [ForumPost!]
    "Number of posts in the topic"
    postsCount: Int!
    "State of this topic, can be open or closed"
    state: String!
    "Title for this topic"
    title: String!
    "SEO-specific title for this topic"
    titleSeo: String!
    "URL for this topic"
    topicUrl: String
    "Number of views this topic has received"
    views: Int!
    "TODO"
    visible: String!
}

"A Game"
type Game {
    "Time that this game was approved, after being submitted by a community member"
    approvedAt: DateTime
    "Schema for game artwork (V1 for game tile only, V2 for multiple artwork assets)."
    artworkSchema: GameArtworkSchema
    "Tags available for collections under this specific game, including global tags."
    availableTags: [Tag!]
    "Number of collections within this game"
    collectionCount: Int
    "True if the name of this game is a copyrighted asset"
    copyrightedName: Boolean!
    "Nexus-specific domain name, used to separate games on the Nexus Mods website."
    domainName: String!
    "Number of total downloads for mods in this game"
    downloadCount: BigInt
    "URL to the game's forum"
    forumUrl: String
    "Genre of this game"
    genre: String
    "The database ID for this game."
    id: Int!
    "Number of uploaded images within this game"
    imageCount: Int
    "Number of uploaded images, supporter images, and videos within this game"
    mediaCount: Int
    "Number of mods within this game"
    modCount: Int
    "Name of this game"
    name: String!
    "Tags only available for collections under this specific game."
    specificTags: [Tag!]
    "Number of uploaded supporter images within this game"
    supporterImageCount: Int
    "Number of days to consider for trending mods"
    trendingPeriodDays: Int!
    "Number of total unique downloads for mods in this game"
    uniqueDownloadCount: BigInt
    "Number of uploaded videos within this game"
    videoCount: Int
}

"Game artwork is set individually. This describes the schema for the artwork."
type GameArtwork {
    "V1 prior to May 2025, using one tile image."
    schemaV1: ArtworkSchemaV1!
    "V2 introduced May 2025, comprising tile, hero, and thumbnail images."
    schemaV2: ArtworkSchemaV2!
}

"The connection type for Game."
type GameConnection {
    "A list of edges."
    edges: [GameEdge]
    "A list of nodes."
    nodes: [Game]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type GameEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Game
}

"Represents a game expansion (DLC)"
type GameExpansion {
    "The ID of the game that the expansion belongs to"
    gameId: ID!
    "The ID of the game expansion"
    id: ID!
    "The name of the game expansion"
    name: String!
}

type GamePage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [Game!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"A version of a specific game."
type GameVersion {
    "Unique ID for referring to this version in future queries"
    id: ID!
    "Game version reference"
    reference: String!
}

"Autogenerated return type of GiveKudosMutation."
type GiveKudosMutationPayload {
    "True if the user was successfully given kudos"
    success: Boolean!
}

"A sitewide notice to be displayed to all users"
type GlobalNotice {
    "Content of the notice"
    content: String!
    "Date of the notice"
    date: DateTime!
    "Staff member who created the notice"
    staff: User!
}

"Autogenerated return type of HideCollectionBugReportMutation."
type HideCollectionBugReportMutationPayload {
    "Collection bug report which was hidden"
    collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of HideCommentMutation."
type HideCommentMutationPayload {
    "The comment that was hidden."
    comment: Comment!
}

"Autogenerated return type of IgnoreUserMutation."
type IgnoreUserMutationPayload {
    "If true, the user is blocked."
    success: Boolean!
}

"An image"
type Image implements Node {
    "If true, this image contains adult content"
    adult: Boolean
    "Whether comments are allowed on the image."
    allowComments: Boolean
    "Whether ratings are allowed on the image."
    allowRating: Boolean
    "A caption for this image"
    caption: String!
    "An image category"
    category: ImageCategory!
    "Time of when this image was first created."
    createdAt: DateTime!
    "A detailed description of this image"
    description: String!
    "Game this image belongs to"
    game: Game!
    "ID of the object."
    id: ID!
    "Status of this image"
    mediaStatus: MediaStatus!
    "Name of the image file"
    name: String!
    "Uploader of this image"
    owner: User!
    "Rating of this image"
    rating: Int!
    "URL of the site this image is hosted on"
    siteUrl: String!
    "URL of the thumbnail of this image"
    thumbnailUrl: String!
    "A title for this image"
    title: String
    "URL of this image"
    url: String!
    "True if the viewer (current user) has ignored this image's author"
    viewerBlocked: Boolean!
    "View count of this image"
    views: Int!
}

"An image category"
type ImageCategory {
    "Unix timestamp of category creation"
    date: Int
    "The database ID for this game."
    gameId: Int!
    "The database ID for this image category."
    id: ID!
    "Name of this category"
    name: String!
}

"Autogenerated return type of IssueWarningToUserMutation."
type IssueWarningToUserMutationPayload {
    "Warning issued successfully"
    success: Boolean
}

"A Tag"
type LegacyTag implements Node {
    "If true, this tag is blockable by the user"
    blockable: Boolean!
    """

    Games this
    tag is used for. Will be nil if global is true, as this tag would apply to all games
    """
    games(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): GameConnection
    "If true, this Tag is global and not intended for a specific game"
    global: Boolean!
    "ID of this tag"
    id: ID!
    "Name of this tag"
    name: String!
    "ID of the parent tag, if any"
    parentId: ID
}

"Autogenerated return type of LegacyUpdateModerationWarningMutation."
type LegacyUpdateModerationWarningMutationPayload {
    "Moderation warning updated successfully"
    success: Boolean
}

"Autogenerated return type of LegacyUpdatePreferencesMutation."
type LegacyUpdatePreferencesMutationPayload {
    "User preferences updated successfully"
    success: Boolean
}

"A set of user donation preferences."
type LegacyUserDonationPreferences implements Node {
    "Whether the user has enabled author premium donations."
    donateAuthorpremium: Boolean!
    "Whether the user has enabled own premium donations."
    donateOwnpremium: Boolean!
    "The maximum amount of premium time in months a user can donate (0 is Lifetime, or no limit)."
    donatePremiumMax: Int!
    "Whether the user has enabled profile donations."
    donateProfile: Boolean!
    "Whether the user has enabled straight donations."
    donateStraight: Boolean!
    "ID of the object."
    id: ID!
    "The user's PayPal email address."
    paypal: String!
}

"Autogenerated return type of LikeCommentMutation."
type LikeCommentMutationPayload {
    "The comment that was liked."
    comment: Comment!
}

"Autogenerated return type of ListCollectionMutation."
type ListCollectionMutationPayload {
    "Returns true if collection was listed"
    success: Boolean!
}

"Autogenerated return type of LockCommentMutation."
type LockCommentMutationPayload {
    "The comment that was locked."
    comment: Comment!
}

"Autogenerated return type of LockThreadMutation."
type LockThreadMutationPayload {
    "The comment thread that was locked."
    commentThread: CommentThread!
}

type MediaUnionPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [MediaUnion!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"A mod"
type Mod {
    "If true, this mod contains adult content"
    adult: Boolean @deprecated(reason: "Deprecated in favour of `adult_content`.")
    "If true, this mod contains adult content"
    adultContent: Boolean
    "Author of this mod"
    author: String
    "Category of this mod"
    category: String!
    "Time of when this mod was first created."
    createdAt: DateTime!
    "A detailed description of this mod"
    description: String!
    "Download count of this mod"
    downloads: Int!
    "Endorsement count of this mod"
    endorsements: Int!
    "Size of the primary mod file in kilobytes"
    fileSize: Int
    "Game changed by this mod"
    game: Game!
    "The database ID for this game."
    gameId: Int!
    "The database ID for this mod."
    id: ID!
    "If true, this mod is blocked from earning DP"
    isBlockedFromEarningDp: Boolean
    "Mirrors for this mod"
    mirrors: [ModMirror!]
    "A mod category"
    modCategory: ModCategory
    "The database ID for this mod."
    modId: Int!
    "Requirements of this mod"
    modRequirements: ModRequirements!
    "Name of this mod"
    name: String!
    "URL for the main mod image"
    pictureUrl: String
    "Status of this mod"
    status: String!
    "A brief summary of this mod"
    summary: String!
    "URL for the blurred thumbnail mod image"
    thumbnailBlurredUrl: String
    "URL for the large blurred thumbnail mod image"
    thumbnailLargeBlurredUrl: String
    "URL for the large thumbnail mod image"
    thumbnailLargeUrl: String
    "URL for the thumbnail mod image"
    thumbnailUrl: String
    "The database ID for this mod."
    uid: ID!
    "Time of when this mod was last updated."
    updatedAt: DateTime!
    "Uploader of this mod"
    uploader: User!
    "Version of this mod"
    version: String!
    "True if the viewer (current user) has blocked this mod"
    viewerBlocked: Boolean!
    "A timestamp indicating the last time the user downloaded this mod"
    viewerDownloaded: DateTime
    """

    True indicates endorsement, false for
    abstention. Will be null if the user has not endorsed the mod
    """
    viewerEndorsed: Boolean
    "True if the viewer (current user) is blocked from interacting with this mod"
    viewerIsBlocked: Boolean
    "If true, the viewer (current user) is tracking this mod."
    viewerTracked: Boolean!
    "True if the mod has been updated since the viewer (current user) downloaded it"
    viewerUpdateAvailable: Boolean
}

"The mod analytics for a specific month"
type ModAnalyticsByMonthNode {
    "Month"
    month: Int!
    "Total downloads"
    totalDownloads: BigInt!
    "Unique downloads"
    uniqueDownloads: BigInt!
    "Year"
    year: Int!
}

"A page of mod analytics grouped by month"
type ModAnalyticsByMonthPage {
    "A list of mod analytics by month nodes"
    nodes: [ModAnalyticsByMonthNode!]!
    "Information about the page"
    pageInfo: OffsetBasedPageInfo!
    "The total number of downloads for mods with which this user is affiliated"
    totalDownloads: BigInt!
    "The total number of unique downloads for mods with which this user is affiliated"
    totalUniqueDownloads: BigInt!
}

"The analytics for a mod within a month"
type ModAnalyticsForMonthNode {
    "Mod"
    mod: Mod!
    "Total downloads"
    totalDownloads: BigInt!
    "Unique downloads"
    uniqueDownloads: BigInt!
}

"A page of mod analytics grouped by month"
type ModAnalyticsForMonthPage {
    "A list of mod analytics for month nodes"
    nodes: [ModAnalyticsForMonthNode!]!
    "Information about the current page"
    pageInfo: OffsetBasedPageInfo!
    "The total number of downloads for the month"
    totalDownloads: BigInt!
    "The total number of unique downloads for the month"
    totalUniqueDownloads: BigInt!
}

"A mod category"
type ModCategory {
    "The database ID for this mod category."
    categoryId: Int!
    "Unix timestamp of category creation"
    date: Int
    "The database ID for this game."
    gameId: Int!
    "Comma separated mod category id and game id"
    id: ID!
    "Name of this category"
    name: String!
    "Comma separated list of legacy tag IDs"
    tags: String @deprecated(reason: "These tag identifiers are no longer used")
}

"A Mod Endorsement"
type ModEndorsement {
    "Id of endorsed entity"
    modUid: BigInt!
    "Endorsement status: abstained/endorsed"
    status: String!
    "The database ID for this endorsement."
    userId: Int!
}

"The connection type for User."
type ModEndorserConnection {
    "A list of edges."
    edges: [ModEndorserEdge]
    "A list of nodes."
    nodes: [User]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"Mod endorser edge"
type ModEndorserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "Time of endorsement"
    endorsedAt: DateTime!
    "The item at the end of the edge."
    node: User
}

"Files belonging to a mod"
type ModFile implements Node {
    "Human-readable mod category"
    category: ModFileCategory!
    "The database ID for this Mod category."
    categoryId: ModFileCategory!
    "Patch notes for this mod file version"
    changelogText: [String!]!
    "Number of downloads for this file"
    count: Int!
    "Unix Timestamp for when this file was uploaded"
    date: Int!
    "Description for this file"
    description: String
    "Forms a composite key with the game_id"
    fileId: Int!
    "Game that this file relates to"
    game: Game!
    "ID of the object."
    id: ID!
    "If true, this file can be downloaded by a mod manager"
    manager: Int!
    "Mod that this file belongs to"
    mod: Mod!
    "The database ID for this mod."
    modId: Int!
    "File name"
    name: String!
    "User that uploaded this file"
    owner: User!
    "If true, this file is the primary file for the mod"
    primary: Int!
    "URL for reporting this file"
    reportLink: String!
    "If true, popup will be displayed for showing the requirements"
    requirementsAlert: Int!
    "Status of virus scanning on this file"
    scanned: VirusScanStatus!
    "Status of virus scanning on this file"
    scannedV2: VirusScanStatus!
    "Size of this file, in kilobytes"
    size: Int!
    "Size of this file, in bytes"
    sizeInBytes: BigInt
    "Number of downloads for this file"
    totalDownloads: Int!
    "Number of unique downloads for this file"
    uCount: Int!
    "Unique ID for this file"
    uid: ID!
    "Number of unique downloads for this file"
    uniqueDownloads: Int!
    "URL to download this file"
    uri: String!
    "Version this file relates to"
    version: String!
}

type ModFilePage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [ModFile!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"A download mirror for a mod"
type ModMirror {
    "Download count for this mirror"
    count: Int
    "The database ID for this game."
    gameId: Int!
    "The database ID for this mod mirror."
    id: ID!
    "The database ID for this mod."
    modId: Int!
    "Name of this mirror"
    name: String!
    "Download count for this mirror"
    totalDownloads: Int
    "URI for this mirror"
    uri: String
}

type ModPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [Mod!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"Represents a mod requirement"
type ModRequirement {
    "If true, the requirement is external to the site. See the url field for the address."
    externalRequirement: Boolean!
    "The ID of the game that the required mod belongs to"
    gameId: ID!
    "The ID of the mod requirement"
    id: ID!
    "The ID of the mod that is required"
    modId: ID!
    "The name of the mod required"
    modName: String!
    "Notes about the mod requirement"
    notes: String
    "The URL of the mod that is required by the mod"
    url: String!
}

type ModRequirementPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [ModRequirement!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"Represents the requirements of a mod"
type ModRequirements {
    "The DLC (expansion) requirements of the mod"
    dlcRequirements: [ModRequirementsDlc!]!
    "Other mods that require this mod"
    modsRequiringThisMod(count: Int, offset: Int): ModRequiringPage!
    "Required mods for this mod"
    nexusRequirements(count: Int, offset: Int): ModRequirementPage!
}

"Represents the DLC (expansion) requirements of a mod"
type ModRequirementsDlc {
    "The game expansion (DLC) required by the mod"
    gameExpansion: GameExpansion!
    "Notes about the expansion (DLC) requirement"
    notes: String
}

"Represents a mod requirement"
type ModRequiring {
    "If true, the requirement is external to the site. See the url field for the address."
    externalRequirement: Boolean!
    "The ID of the game that the mod belongs to"
    gameId: ID!
    "The ID of the mod requirement"
    id: ID!
    "The ID of the mod that is required"
    modId: ID!
    "The name of the mod that requires the mod"
    modName: String!
    "Notes about the mod requirement"
    notes: String
    "The URL of the mod that is required by the mod"
    url: String!
}

type ModRequiringPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [ModRequiring!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"An upload"
type ModUpload {
    "If true, this file has been claimed by a user"
    claimed: Boolean
    "If true, the content preview has been generated for this upload"
    contentPreviewGenerated: Boolean
    "Time of when this upload was first created."
    createdAt: String!
    "Time of when this upload was discarded."
    discardedAt: String
    "If true, this file has been reassembled from the uploaded chunks"
    fileChunksReassembled: Boolean
    "Can't get field description; multiple fields named 'file_id' detected on Types::Objects::Mods::ModFileType"
    fileId: Int
    "A Game"
    game: Game
    "The database ID for this upload."
    id: String!
    "The virus scanning status of this upload, provided by our internal virus scanning tools"
    internalVirusScanStatus: Int
    "The MD5 hash for this object in our object store"
    md5: String
    "Files belonging to a mod"
    modFile: ModFile
    "The database ID for this mod."
    modId: Int
    "If true, this file has been uploaded to object store"
    s3UploadComplete: Boolean
    "The URL for this object in our object store"
    s3Url: String
    "The HAS256 hash for this object in our object store"
    sha256: String
    "The size of this upload in bytes"
    sizeBytes: String
    "System filename for this upload"
    systemFileName: String
    "Temporary filename for this upload"
    tempFileName: String!
    "Time of when this upload was last updated."
    updatedAt: String!
    "Type of upload"
    uploadType: String
    "A Nexus Mods user"
    user: User
    "Number of positive reports from VirusTotal"
    virusTotalPositives: Int
    "The virus scanning status of this upload, provided by VirusTotal"
    virusTotalStatus: Int
    "The URL of the VirusTotal report for this upload"
    virusTotalUrl: String
}

"Autogenerated return type of ModerateMutation."
type ModerateMutationPayload {
    "Return the moderation type"
    moderation: Moderation!
    "if true, this entity is put into moderation"
    success: Boolean!
}

"A moderation entry"
type Moderation {
    "Time of when this moderation was first created."
    createdAt: DateTime!
    "If true, this moderation entry can be edited"
    editable: Boolean!
    "The database ID for this moderation."
    id: ID!
    "Polymorphic ID of the entity that is being moderated"
    moderatableId: ID!
    "Polymorphic Type of the entity that is being moderated"
    moderatableType: Moderatable!
    """

    Array of fixes applied for this
    moderation
    """
    moderationFixes: [ModerationFix!]
    """

    Reason for placing this entity
    into moderation
    """
    moderationReason: ModerationReason!
    "The database ID for this staff member."
    staffId: ID!
    "Content for the staff note"
    staffNote: String
    "Date this entity was unlocked"
    unlockedAt: DateTime
    "User that unlocked this entity"
    unlockedBy: ID
    "Content for the message to show when unlocked"
    unlockedNote: String
    "Time of when this moderation was last updated."
    updatedAt: DateTime!
    "Staff member that put this entity into moderation"
    user: User!
    "Content for the user note"
    userNote: String
}

"A moderation fix submission"
type ModerationFix {
    "User who authored this moderation fix"
    author: User!
    "ID of the user who authored this moderation fix"
    authorId: ID!
    "Time of when this moderation fix was first created."
    createdAt: DateTime!
    "Description of this moderation fix"
    description: String
    "The database ID for this moderation fix."
    id: ID!
    "Type of moderation fix"
    moderation: Moderation!
    "Status of this moderation fix"
    status: ModerationFixStatus!
    "Time of when this moderation fix was last updated."
    updatedAt: DateTime!
}

"A moderation reason"
type ModerationReason {
    "Time of when this moderation reason was first created."
    createdAt: DateTime!
    "The database ID for this moderation reason."
    id: ID!
    "Reason for moderation"
    reason: String!
    "Resolution of the moderation"
    resolution: String
    "Time of when this moderation reason was last updated."
    updatedAt: DateTime!
}

"A moderation_warning"
type ModerationWarning implements Node {
    "Category Id"
    category: ModerationWarningCategoryEnum!
    "Unix timestamp of moderation warning date"
    date: Int!
    "The database ID for this moderation warning."
    id: ID!
    "Has been read"
    isRead: Boolean!
    "Moderation warning link"
    link: String!
    "A moderation restriction"
    moderationWarningRestrictions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): ModerationWarningRestrictionConnection
    "Forum post linked to warning"
    post: ForumPost
    "Post id of moderation warning"
    postId: ID
    "Public reason"
    publicReason: String
    "Reason for moderation warning"
    reason: String!
    "User id who removed moderation warning"
    removedBy: ID
    "Removed date of moderation warning"
    removedDate: Int
    "Removed reason"
    removedReason: String
    "Issuer of warning"
    staff: User!
    "User warning has been applied to"
    user: User!
}

"The connection type for ModerationWarning."
type ModerationWarningConnection {
    "A list of edges."
    edges: [ModerationWarningEdge]
    "A list of nodes."
    nodes: [ModerationWarning]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type ModerationWarningEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ModerationWarning
}

"A moderation restriction"
type ModerationWarningRestriction implements Node {
    "Duration of restriction"
    duration: Int!
    "Restricted feature"
    featureId: ModerationWarningRestrictionFeatureEnum
    "The database ID for this moderation restriction."
    id: ID!
}

"The connection type for ModerationWarningRestriction."
type ModerationWarningRestrictionConnection {
    "A list of edges."
    edges: [ModerationWarningRestrictionEdge]
    "A list of nodes."
    nodes: [ModerationWarningRestriction]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type ModerationWarningRestrictionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ModerationWarningRestriction
}

"Autogenerated return type of ModifyImageForCollectionMutation."
type ModifyImageForCollectionMutationPayload {
    "Image that was updated on the collection"
    image: CollectionImage!
    "True when image was updated"
    updated: Boolean!
}

"All mutations to update, create and delete data"
type Mutation {
    "Abstains from mod endorsement."
    abstainFromModEndorsement(
        "ID of the mod the endorsement is for."
        modUid: String!
    ): AbstainFromModEndorsementMutationPayload
    """

    Marks the fix as accepted and takes the collection out of moderation.
    Only collection moderators can call this mutation
    """
    acceptModerationFix(
        "The database ID for this moderation fix."
        moderationFixId: ID!
    ): AcceptModerationFixMutationPayload
    "Adds a game to a user's favourites"
    addFavouriteGame(
        "The game to add"
        gameId: ID!
    ): AddFavouriteGameMutationPayload
    "Adds a new header image to a collection"
    addHeaderImageToCollection(
        "ID of collection to add image to"
        collectionId: ID!,
        "Image to be added"
        image: UploadImageInput!
    ): AddHeaderImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Adds a new image to a collection"
    addImageToCollection(
        "ID of collection to add image to"
        collectionId: ID!,
        "ID of collection revision to add image to"
        collectionRevisionId: ID,
        "Image to be added"
        image: UploadImageInput!
    ): AddImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Adds a tag to a collection. User must have the `collection:add_tag` permission"
    addTagToCollection(
        "ID of collection to add tags to"
        collectionId: Int!,
        "IDs of tags to add to the collection"
        tagIds: [ID!]!
    ): AddTagToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Adds a new tile image to a collection"
    addTileImageToCollection(
        "ID of collection to add image to"
        collectionId: ID!,
        "Image to be added"
        image: UploadImageInput!
    ): AddTileImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Adds a new image to a collection"
    addVideoToCollection(
        "ID of collection to add video to"
        collectionId: ID!,
        "ID of collection revision to add video to"
        collectionRevisionId: ID,
        "Video to be added"
        video: UploadVideoInput!
    ): AddVideoToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Updates existing Moderation entity. Used to update details about the moderation or to unlock it."
    amendModeration(
        """

        Change collection
        status upon amending the moderation.
        """
        collectionStatus: CollectionStatus,
        "Enable or disable editing of the entity."
        editable: Boolean,
        "ID of the Moderation entity"
        id: ID!,
        "Change moderation reason."
        moderationReasonId: ID,
        "Note displayed to internally to staff members."
        staffNote: String,
        "When TRUE, the entity will no longer be moderated."
        unlocked: Boolean,
        """

        Note for the end user when moderation is
        unlocked
        """
        unlockedNote: String,
        "Note displayed to the end user."
        userNote: String
    ): AmendModerationMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Ignores a specific user for the current user."
    blockAuthor(
        "This is an alias for userId."
        authorId: ID,
        "This is an alias for userName."
        authorName: String,
        "The ID of the user to block (this or user_name must be set)."
        userId: ID,
        "The username of the user to block (this or user_id must be set)"
        userName: String
    ): BlockUserMutationPayload @deprecated(reason: "This mutation will be replaced with ignore_user mutation")
    "Allows the current user to block all of a user's existing mods from earning DP."
    blockModsFromEarningDp(
        "The ID of the user for whom to block mods."
        userId: ID
    ): BlockModsFromEarningDpMutationPayload
    "Blocks a specific tag for the current user."
    blockTag(
        "The database ID for this tag."
        tagId: ID!
    ): BlockTagMutationPayload
    "Changes a collection owner."
    changeCollectionOwner(
        "Collection ID"
        collectionId: ID!,
        "New owner ID"
        ownerId: ID!
    ): ChangeCollectionOwnerPayload
    "Clears the status of an existing bug report on a collection"
    clearCollectionBugReportModerationStatus(
        "ID of the collection bug report to clear status of"
        bugReportId: ID!
    ): ClearCollectionBugReportModerationStatusMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Clears the moderation status of a comment."
    clearCommentModerationStatus(
        "The database ID for this comment."
        commentId: ID!
    ): ClearCommentModerationStatusMutationPayload
    "Clears the moderation status of a comment thread."
    clearCommentThreadModerationStatus(
        "The database ID for this comment thread."
        commentThreadId: ID!
    ): ClearThreadModerationStatusMutationPayload
    "Marks a collection bug report as closed. Can be called by the reporter or the collection curator, but only the curator can specify a closure_reason"
    closeCollectionBugReport(
        "ID of the collection bug report to close"
        bugReportId: ID!,
        "The status of the bug report, e.g. Resolved, Won't fix"
        closureReason: BugReportClosureReason!
    ): CloseCollectionBugReportMutationPayload
    "Creates an API Key for a user"
    createApiKey(
        "The application to create the key for. Pass null to create a personal API key."
        applicationId: ID
    ): CreateApiKeyMutationPayload
    "Creates a revision changelog entry"
    createChangelog(
        "Changelog description"
        description: String!,
        "Revision ID"
        revisionId: ID!
    ): CreateChangelogMutationPayload
    """

    Create a new Collection. Must be passed the collection data from the manifest containing
    the manifest schema.
    """
    createCollection(
        "Collection payload required for the collection creation."
        collectionData: CollectionPayload!,
        """

        UUID of the temporary collection file. Once the creation process is completed,
        the file will be moved to a permanent storage space.
        """
        uuid: String!
    ): CreateCollectionMutationPayload
    "Creates a new bug report for a collection"
    createCollectionBugReport(
        "Array of attachment ids of uploaded files"
        attachmentIds: [ID!],
        "ID of collection to add bug report to"
        collectionId: ID!,
        "Number of collection revision to add bug report to"
        collectionRevisionNumber: Int!,
        "Description for the new bug report"
        description: String,
        "Title of the new bug report"
        title: String!
    ): CreateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Creates a comment."
    createComment(
        "An optional array of attachment_ids from uploaded files to attach."
        attachmentIds: [ID!],
        "The comment body."
        body: String!,
        "The database ID for this comment thread."
        commentThreadId: ID!,
        "An optional comment ID to reply to."
        replyToId: ID
    ): CreateCommentMutationPayload
    "Create a new message"
    createMessage(
        "Body of message"
        body: String!,
        "Title of message"
        title: String!,
        "User IDs of recipients"
        to: [Int!]!
    ): CreateMessagePayload
    "Creates an endorsement for a mod."
    createModEndorsement(
        "ID of the mod the endorsement is for."
        modUid: String!
    ): CreateModEndorsementMutationPayload
    "Creates a moderation note about a user"
    createNoteAboutUser(
        "The moderation note"
        note: String!,
        "The database ID for this user."
        userId: ID!
    ): CreateNoteAboutUserMutationPayload
    """

    Creates a new Collection Revision, or updates an existing Collection Revision (if a
    draft already exists )
    """
    createOrUpdateRevision(
        "The data payload used to create a collection revision"
        collectionData: CollectionPayload!,
        "The database ID for this collection."
        collectionId: Int!,
        "TODO"
        uuid: String!
    ): CreateOrUpdateRevisionMutationPayload
    "Creates a new collection Tag"
    createTag(
        "Is this an adult content tag"
        adult: Boolean,
        "Tag category ID"
        categoryId: ID,
        """

        Array containing Game IDs to
        be associated with the tag
        """
        gameIds: [ID!],
        """

        Is the tag global
        (not game specific)
        """
        global: Boolean,
        "Tag name"
        name: String!
    ): CreateTagMutationPayload
    "Deletes a user's API Key"
    deleteApiKey(
        "The application to delete the key for."
        applicationId: ID!
    ): DeleteApiKeyMutationPayload
    "Deletes a user's personal API Key"
    deletePersonalApiKey: DeletePersonalApiKeyMutationPayload
    "Discards an entire Collection and its associated entities"
    discardCollection(
        "Collection ID"
        collectionId: ID!,
        "Discard reason"
        reason: String!
    ): DiscardCollectionMutationPayload
    "Discards a comment."
    discardComment(
        "The database ID for this comment."
        commentId: ID!
    ): DiscardCommentMutationPayload
    """

    Discards a Collection Revision. Revision can only be discarded if it is a DRAFT or is not older than
    24 hours and has no more than a 100 unique downloads.
    """
    discardRevision(
        "Collection ID"
        collectionId: ID!,
        "Discard Reason"
        reason: String,
        "Revision number"
        revisionNumber: Int!
    ): DiscardRevisionMutationPayload
    "Removed an existing tag. User must have the `tag:discard` permission"
    discardTag(
        "The database ID for this category."
        id: ID!
    ): DiscardTagMutationPayload
    "Updates the core details for a collection such as the name, description and category"
    editCollection(
        "If true, allow user-uploaded content"
        allowUserMedia: Boolean,
        "ID of the parent category"
        categoryId: ID,
        "The database ID for this collection."
        collectionId: Int!,
        "Description of this collection"
        description: String,
        "If true, media needs to be verified"
        manuallyVerifyMedia: Boolean,
        "Name of this collection"
        name: String,
        "Collection summary"
        summary: String
    ): EditCollectionMutationPayload
    """

    Creates an endorsement for a generic Endorsable model. TODO: This will be moving to a
    model-specific mutation
    """
    endorse(
        """

        Used to determine whether the endorsement entry is used for abstaining.
        Users that abstain from endorsing a file will not get send future endorsement reminders.
        """
        abstain: Boolean,
        "ID of an entity the endorsement is for."
        modelId: Int!,
        "Type of an entity the endorsement is for."
        modelType: String!
    ): CreateEndorsementMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Allows the current user to give kudos to another user"
    giveKudos(
        "The ID of the user to give kudos to."
        kudosUserId: ID
    ): GiveKudosMutationPayload
    "Hides a bug report on a collection from public view"
    hideCollectionBugReport(
        "ID of the collection bug report to hide"
        bugReportId: ID!,
        "Company internal reason to hide the bug report"
        internalReason: String,
        "Public reason to hide the bug report"
        reason: String
    ): HideCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Hides a comment."
    hideComment(
        "The database ID for this comment."
        commentId: ID!,
        "The internal reason for hiding the comment. Only visible to admins and moderators."
        internalReason: String,
        "The reason for hiding the comment."
        reason: String!
    ): HideCommentMutationPayload
    "Ignores a specific user for the current user."
    ignoreUser(
        "The ID of the user to block (this or user_name must be set)."
        userId: ID,
        "The username of the user to block (this or user_id must be set)"
        userName: String
    ): IgnoreUserMutationPayload
    "Issues a moderation warning to a user"
    issueWarningToUser(
        "The database ID for this comment."
        commentId: ID,
        "The public reason for the warning"
        publicReason: String,
        "The reason for the warning"
        reason: String!,
        "Reference links for the warning"
        referenceLinks: [String!],
        "Restrictions to apply to the user"
        restrictions: [ModerationRestrictionInput!],
        "The database ID for this user."
        userId: ID!,
        "Whether the warning is informal or formal"
        warning: FormalOrInformalWarning!
    ): IssueWarningToUserMutationPayload
    "Likes a comment."
    likeComment(
        "The database ID for this comment."
        commentId: ID!
    ): LikeCommentMutationPayload
    """

    Sets a collection as `listed`. A collection can only be listed if there are published revisions.
    User must have the `collection:set_status` permission
    """
    listCollection(
        "The database ID for this collection."
        collectionId: Int!
    ): ListCollectionMutationPayload
    "Locks a comment."
    lockComment(
        "The database ID for this comment."
        commentId: ID!
    ): LockCommentMutationPayload
    "Locks a comment thread."
    lockCommentThread(
        "The database ID for this comment thread."
        commentThreadId: ID!
    ): LockThreadMutationPayload
    """

    Sets a collection as `under_moderation`, allowing the user to provide a reason and the
    ability to 'lock' the collection against future editing. User must have the `collection:moderate` permission.
    """
    moderate(
        "If true, this entity cannot be edited by the author"
        editable: Boolean,
        "Moderatable ID - ID of the object intended to be moderated"
        id: ID!,
        "The database ID for this moderation reason."
        moderationReasonId: ID!,
        "Moderation note only visible to staff"
        staffNote: String,
        "Moderatable type"
        type: Moderatable!,
        "Moderation note visible to the user"
        userNote: String
    ): ModerateMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Updates an image on a collection"
    modifyImageForCollection(
        "ID of collection to update image on"
        collectionId: ID!,
        "Image to be updated"
        image: UpdateImageInput!
    ): ModifyImageForCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Re-opens a previously closed bug report. Can be called by the report or the collection curator"
    openCollectionBugReport(
        "ID of the collection bug report to open"
        bugReportId: ID!
    ): OpenCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Pins a comment. User must have the `comment:pin?` permission"
    pinComment(
        "The database ID for this comment."
        commentId: ID!
    ): PinCommentMutationPayload
    "Publishes a Collection Revision"
    publishRevision(
        """

        Allows a curator to
        set the collection status when this revision is published
        """
        collectionStatus: CollectionStatus,
        """

        Does this revision contain adult content
        resources
        """
        hasAdultResources: Boolean,
        "Collection Revision ID"
        revisionId: ID!
    ): PublishRevisionMutationPayload
    "Votes for a generic Rateable model. TODO: This will be moved to model-specific mutations"
    rate(
        "ID of the entity the rating is for"
        id: ID!,
        "Rating value"
        rating: RatingOptions!,
        "Type of the entity the rating is for"
        type: Ratable!
    ): CreateRatingMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    """

    Marks the moderation fix as rejected. The collection status is not changed.
    Only collection moderators can call this mutation
    """
    rejectModerationFix(
        "The database ID for this moderation fix."
        moderationFixId: ID!
    ): RejectModerationFixMutationPayload
    "Removes the current user's like from a comment."
    removeCommentLike(
        "The database ID for this comment."
        commentId: ID!
    ): RemoveCommentLikeMutationPayload
    "Removes a game from a user's favourites"
    removeFavouriteGame(
        "The game to remove"
        gameId: ID!
    ): RemoveFavouriteGameMutationPayload
    "Removes a header image from a Collection"
    removeHeaderImageFromCollection(
        "The database ID for this collection."
        collectionId: ID!
    ): RemoveHeaderImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Removes an image from a Collection"
    removeImageFromCollection(
        "The database ID for this collection."
        collectionId: ID!,
        "The database ID for this image."
        imageId: ID!
    ): RemoveImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Allows the current user to remove kudos from another user"
    removeKudos(
        "The ID of the user to remove kudos from."
        kudosUserId: ID
    ): RemoveKudosMutationPayload
    "Removes tags from a collection"
    removeTagFromCollection(
        "Collection ID"
        collectionId: ID!,
        "Array containing Tag IDs"
        tagIds: [ID!]!
    ): RemoveTagFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Removes a tile image from a Collection"
    removeTileImageFromCollection(
        "The database ID for this collection."
        collectionId: ID!
    ): RemoveTileImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Removes a video from a Collection"
    removeVideoFromCollection(
        "The database ID for this collection."
        collectionId: ID!,
        "The database ID for this video."
        videoId: ID!
    ): RemoveVideoFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Moves an item to a new position in a list."
    reorderItem(
        "The global ID of the item to move."
        id: ID!,
        "The new location of the item, in relation to the target item."
        location: ReorderLocation!,
        "The global ID of the item to move towards."
        targetId: ID!
    ): ReorderItemPayload
    "Reorders pinned comments. User must have the `comment:pin?` permission"
    reorderPinnedComments(
        "The database ID for this comment."
        commentIds: [ID!]!
    ): ReorderPinnedCommentsMutationPayload
    "Restores a discarded comment."
    restoreComment(
        "The database ID for this comment."
        commentId: ID!
    ): RestoreCommentMutationPayload
    """

    Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as
    a revision that should not be used anymore.
    """
    retractRevision(
        "Retraction Reason"
        reason: String!,
        "Collection Revision ID"
        revisionId: ID!
    ): RetractRevisionMutationPayload
    "Submits a moderation fix against a moderation that is pending acceptance"
    submitModerationFix(
        """

        Additional information from the curation for
        this fix
        """
        description: String,
        "The database ID for this moderation fix."
        moderationId: ID!
    ): SubmitModerationFixMutationPayload
    "Allows the current user to track a mod"
    trackMod(
        "The ID of the mod to be tracked."
        modUid: ID!
    ): TrackModMutationPayload
    "Allows the current user to track another user"
    trackUser(
        "The ID of the user to be tracked."
        trackedUserId: ID
    ): TrackUserMutationPayload
    "Unignore a specific author for the current user."
    unblockAuthor(
        "This is an alias for userId."
        authorId: ID,
        "This is an alias for userName."
        authorName: String,
        "The ID of the author to unignore (this or user_name must be set)."
        userId: ID,
        "The username of the user to unignore (this or user_id must be set)."
        userName: String
    ): UnblockUserMutationPayload
    "Allows the current user to unblock all of a user's existing mods from earning DP."
    unblockModsFromEarningDp(
        "The ID of the user for whom to unblock mods."
        userId: ID
    ): UnblockModsFromEarningDpMutationPayload
    "Unblocks a specific tag for the current user."
    unblockTag(
        "The database ID for this tag."
        tagId: ID!
    ): UnblockTagMutationPayload
    "Unignore a specific author for the current user."
    unignoreUser(
        "The ID of the author to unignore (this or user_name must be set)."
        userId: ID,
        "The username of the user to unignore (this or user_id must be set)."
        userName: String
    ): UnignoreUserMutationPayload
    "Unlists a Collection Revision from the public Nexus Mods pages."
    unlistCollection(
        "Collection ID"
        collectionId: ID!
    ): UnlistCollectionMutationPayload
    "Unpins a comment. User must have the `comment:unpin?` permission"
    unpinComment(
        "The database ID for this comment."
        commentId: ID!
    ): UnpinCommentMutationPayload
    """

    Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as
    a revision that should not be used anymore.
    """
    unpublishRevision(
        "Retraction Reason"
        reason: String!,
        "Collection Revision ID"
        revisionId: ID!
    ): RetractRevisionMutationPayload @deprecated(reason: "Legacy Field - this will be removed in a future update.")
    "Allows the current user to untrack a mod"
    untrackMod(
        "The ID of the mod to be un-tracked."
        modUid: ID!
    ): UntrackModMutationPayload
    "Makes the current user stop tracking another user"
    untrackUser(
        "The ID of the user to stop tracking."
        trackedUserId: ID
    ): UntrackUserMutationPayload
    "Updates a user's bio (About Me) on their profile"
    updateAboutMe(
        "The new text for the about me section in bio."
        about: String!,
        "The user whose bio we are updating (or current user if nil)."
        userId: ID
    ): UpdateAboutMeMutationPayload
    "Updates existing revision changelog"
    updateChangelog(
        "Changelog ID"
        changelogId: ID!,
        "Changelog description"
        description: String!
    ): UpdateChangelogMutationPayload
    "Updates a bug report on a collection"
    updateCollectionBugReport(
        "Array of attachment ids"
        attachmentIds: [ID!],
        "ID of the collection bug report to update"
        bugReportId: ID!,
        "Number of collection revision to update bug report on"
        collectionRevisionNumber: Int,
        "Description of the new bug report"
        description: String,
        "Title of the new bug report"
        title: String!
    ): UpdateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
    "Updates a comment."
    updateComment(
        "An array of attachment_ids of uploaded files to attach to the new revision.Include all the previous ids or they won't be present on the updated revision.If you don't send an array the previous revisions attachments will be maintained"
        attachmentIds: [ID!],
        "The comment body."
        body: String!,
        "The database ID for this comment."
        commentId: ID!
    ): UpdateCommentMutationPayload
    "Updates a user's country on their profile"
    updateCountry(
        "ISO Country Code (can also be null)"
        country: String,
        "The user whose country to update (current user if omitted)."
        userId: ID
    ): UpdateCountryMutationPayload
    "Updates a game"
    updateGame(
        "New artwork schema to use"
        artworkSchema: GameArtworkSchema,
        "Set to true if the game name is a copyrighted asset"
        copyrightedName: Boolean,
        "ID of the game to update"
        gameId: Int!
    ): UpdateGameMutationPayload
    "Updates a users moderation warning"
    updateModerationWarning(
        "Whether the moderation warning has been read / acknowledged"
        isRead: Boolean!,
        "The database ID for this moderation warning."
        moderationWarningId: ID!
    ): LegacyUpdateModerationWarningMutationPayload
    "Updates a users preferences"
    updatePreferences(
        "Show adult content"
        adult: Boolean,
        "Blur adult images"
        adultBlurImages: Boolean,
        "Replies to posts bump original post"
        bubbleReply: Boolean,
        "Number of comments to show per page"
        comments: PreferencesCommentsEnum,
        "Default media tab"
        defaultMediaTab: PreferencesDefaultMediaTabEnum,
        "Default media tab time range"
        defaultMediaTabTimeRange: PreferencesTimeRangeEnum,
        "Default mods tab"
        defaultModsTab: PreferencesDefaultModsTabEnum,
        "Default mods tab time range"
        defaultModsTabTimeRange: PreferencesTimeRangeEnum,
        "Default sorting option"
        defaultOrder: PreferencesDefaultSortEnum,
        "Default search type"
        defaultSearchType: PreferencesSearchTypeEnum,
        "Default search view"
        defaultSearchView: PreferencesDefaultSearchViewEnum,
        "Display user activity"
        disableProfileActivity: Boolean,
        "Display when user was last active"
        displayLastActivity: Boolean,
        "Preferred download location"
        dlLocation: PreferencesDlLocationEnum,
        "Preferred download method"
        download: PreferencesDownloadMethodEnum,
        "Images added by author in image description"
        imageShowcase: PreferencesImageShowcaseEnum,
        "Display notifications"
        notificationsActive: Boolean,
        "Display game specific notifications when on game pages"
        notificationsGameSpecific: Boolean,
        "User reminder for file ratings"
        reminder: PreferencesReminderEnum,
        "Number of items to show per page"
        results: PreferencesResultsEnum,
        "Activity about tracked files, images and videos"
        subfeedsActivityTracked: Boolean,
        "Activity about a users files, images and videos"
        subfeedsActivityYour: Boolean,
        "Author tracked files, images and videos"
        subfeedsAuthorTracked: Boolean,
        "Comments about tracked files, images and videos"
        subfeedsCommentsTracked: Boolean,
        "Comments about a users files, images and videos"
        subfeedsCommentsYour: Boolean
    ): LegacyUpdatePreferencesMutationPayload
    """

    Updates a specific Collection Revision with new installation information and adult
    content flags
    """
    updateRevision(
        "Whether this revision has adult content"
        adultContent: Boolean,
        "User-provided installation information"
        installationInfo: String,
        "ID of the collection revision to update"
        revisionId: Int!
    ): UpdateRevisionMutationPayload
    "Updates a collection Tag"
    updateTag(
        "Is this an adult content Tag"
        adult: Boolean,
        "Tag category ID"
        categoryId: ID,
        "Games IDs to be associated with the Tag"
        gameIds: [ID!],
        "Is the tag global (non game specific)"
        global: Boolean,
        "Collection Tag ID"
        id: ID!,
        "Tag name"
        name: String
    ): UpdateTagMutationPayload
    "Updates a user's donation preferences."
    updateUserDonationPreferences(
        "Whether the user has enabled author premium donations."
        donateAuthorpremium: Boolean,
        "Whether the user has enabled own premium donations."
        donateOwnpremium: Boolean,
        "The maximum amount of premium time in months a user can donate."
        donatePremiumMax: Int,
        "Whether the user has enabled profile donations."
        donateProfile: Boolean,
        "Whether the user has enabled straight donations."
        donateStraight: Boolean,
        "Whether the user has opted in to the Donation Points program."
        dpOptedIn: Boolean,
        "The user's PayPal email address."
        paypal: String
    ): UpdateUserDonationPreferencesPayload
    "Uploads a file to later be attached to an Attachable entity"
    uploadAttachment(
        "A file to upload that will be later attached to an entity"
        file: Upload!
    ): UploadAttachmentMutationPayload
    "TODO"
    uploadGameArtworkV2(
        "ID of the game to update."
        gameId: Int!,
        "TODO"
        heroFile: Upload,
        "TODO"
        thumbnailFile: Upload,
        "TODO"
        tileFile: Upload
    ): UploadGameArtworkV2MutationPayload
    "Writes a full page notification to a user"
    writeFullPageNotificationToUser(
        "The full page notification message"
        message: String!,
        "The full page notification reference links"
        referenceLinks: [String!],
        "The full page notification title"
        title: String!,
        "The database ID for this user."
        userId: ID!
    ): WriteFullPageNotificationToUserMutationPayload
}

"A News article, stored and originally defined by the legacy forum"
type News {
    "Author of this News Article"
    author: User!
    "The number of comments on this article"
    commentsCount: Int!
    "Content of this news article"
    content: String!
    "Date this news article was created"
    date: ISO8601DateTime!
    "Games this news article is related to"
    games: [Game!]!
    "The name of the image on the forum"
    header: String
    "Is this news article written in HTML?"
    html: Boolean!
    "The database ID for this news."
    id: ID!
    "The name of the image on the forum"
    image: String
    "Category of this news article"
    newsCategory: NewsCategory!
    "If the news article has a source, this is it's name"
    sourceName: String
    "If the news article has a source, this is the URL"
    sourceUrl: String
    "Summary of this news article"
    summary: String!
    "Title of this news article"
    title: String!
    "The name of the uncropped image on the forum"
    uncroppedHeader: String
    "The name of the uncropped image on the forum"
    uncroppedImage: String
}

"A news category"
type NewsCategory {
    "The database ID for this news category."
    id: ID!
    "Name of this category"
    name: String!
}

type NewsPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [News!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"Metadata about a single facet value."
type NodesFacet {
    "Number of results available for this facet value. Affected by values set on other facets."
    count: Int!
    "Name matching the graphql facet request."
    facet: String!
    "Value available for this facet. May be used in a subsequent facet request to filter the results by facet."
    value: String!
}

"Information about a page of items"
type OffsetBasedPageInfo {
    "Whether there is a next page"
    hasNextPage: Boolean!
    "Whether there is a previous page"
    hasPreviousPage: Boolean!
    "The current page number"
    page: Int!
    "The number of items per page"
    pageSize: Int!
    "The total number of items"
    totalCount: Int!
}

"Autogenerated return type of OpenCollectionBugReportMutation."
type OpenCollectionBugReportMutationPayload {
    "Collection bug report which was re-opened"
    collectionBugReport: CollectionBugReport!
}

"Represents a single opted in mod"
type OptedInMod {
    "Time of when this OptedInMod was first created."
    createdAt: DateTime!
    "Game"
    game: Game
    "The ID of the game the mod belongs to"
    gameId: Int!
    "The database ID for this opted in mod."
    id: Int!
    "Mod"
    mod: Mod
    "ID of the that was opted in"
    modId: Int!
    "Ratio of the DP from this mod shared with this user"
    ratio: Float!
    "Uploader of the mod"
    uploader: User
    """

    ID of the uploader of the mod. This
    might not be the current user, as mod authors can share mod DP with other users.
    """
    uploaderId: Int!
}

"A list of mods that this user has been opted into"
type OptedInMods {
    "Number of mods this user has opted in"
    count: Int!
    "Mods that have been opted in"
    entries: [OptedInMod!]!
    "User"
    user: User!
    "ID of the user"
    userId: Int!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"An entity to represent either an account or a bank"
type PaymentEntity {
    "The database ID for this payment entity."
    id: Int!
    "Name of this entity"
    label: String!
    "Type of entity"
    type: String!
}

"A global or entity-specific permission granted to a user"
type Permission {
    "If true, this permission is being granted globally from the user's role"
    global: Boolean!
    "Permission string being granted E.g. 'collection:publish'"
    key: String!
}

"Autogenerated return type of PinCommentMutation."
type PinCommentMutationPayload {
    "The comment that was pinned."
    comment: Comment!
}

"A user preference"
type Preference implements Node {
    "Show adult content"
    adult: Boolean!
    "Blur adult images"
    adultBlurImages: Boolean!
    "Replies to posts bump original post"
    bubbleReply: Boolean!
    "Amount of comments per page."
    comments: PreferencesCommentsEnum!
    "Default media tab."
    defaultMediaTab: PreferencesDefaultMediaTabEnum!
    "Time range values for preferences."
    defaultMediaTabTimeRange: PreferencesTimeRangeEnum!
    "Default mods tab."
    defaultModsTab: PreferencesDefaultModsTabEnum!
    "Time range values for preferences."
    defaultModsTabTimeRange: PreferencesTimeRangeEnum!
    "Default sorting option."
    defaultOrder: PreferencesDefaultSortEnum!
    "Default search types"
    defaultSearchType: PreferencesSearchTypeEnum!
    "Default search view."
    defaultSearchView: PreferencesDefaultSearchViewEnum!
    "Display user activity"
    disableProfileActivity: Boolean!
    "Display when user was last active"
    displayLastActivity: Boolean!
    "Download location."
    dlLocation: PreferencesDlLocationEnum!
    "Preferred download method"
    download: PreferencesDownloadMethodEnum!
    "ID of the object."
    id: ID!
    "Image showcase."
    imageShowcase: PreferencesImageShowcaseEnum!
    "If true, this user is blocking content"
    isBlockingContent: Boolean!
    "Display notifications"
    notificationsActive: Boolean!
    "Game specific notifications when visiting game pages"
    notificationsGameSpecific: Boolean!
    "Endorsement reminder."
    reminder: PreferencesReminderEnum!
    "Amount of results per page."
    results: PreferencesResultsEnum!
    "Activity about tracked files, images and videos"
    subfeedsActivityTracked: Boolean!
    "Activity about a users files, images and videos"
    subfeedsActivityYour: Boolean!
    "Author tracked files, images and videos"
    subfeedsAuthorTracked: Boolean!
    "Comments about tracked files, images and videos"
    subfeedsCommentsTracked: Boolean!
    "Comments about a users files, images and videos"
    subfeedsCommentsYour: Boolean!
}

"returned attributes for presigned post requests"
type PresignedUrl {
    "Presigned URL"
    url: String!
    "UUID"
    uuid: String!
}

"""

A public changelog attached to a collection revision.
If you need to access more fields, use CollectionChangelogType instead.
"""
type PublicCollectionChangelog {
    "The id of the collection revision for which this changelog was created"
    collectionRevisionId: Int!
    "Time of when this collection changelog was first created."
    createdAt: DateTime!
    "The content of the collection changelog, in Markdown format"
    description: String!
    "The database ID for this collection changelog."
    id: Int!
    "The revision number of the collection revision for which this changelog was created"
    revisionNumber: Int!
    "Time of when this collection changelog was last updated."
    updatedAt: DateTime!
}

"""

A public collection revision type.
If you need to access more fields, use CollectionRevisionType instead.
"""
type PublicCollectionRevision {
    "A changelog attached to a collection revision"
    collectionChangelog: PublicCollectionChangelog
    "Time of when this revision was first created."
    createdAt: DateTime!
    "Time of when this revision was discarded."
    discardedAt: DateTime
    "The database ID for this revision."
    id: Int!
    "An average taken from all ratings for this revision"
    overallRating: String
    "A count of all ratings for this revision"
    overallRatingCount: Int
    "Average rating for a single revision and total number of votes"
    rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
    "The revision number"
    revision: Int! @deprecated(reason: "Use `revision_number` instead.")
    "The revision number"
    revisionNumber: Int!
    "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
    revisionStatus: String!
    "Time of when this revision was last updated."
    updatedAt: DateTime!
}

"Autogenerated return type of PublishRevisionMutation."
type PublishRevisionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"Queries for fetching and filtering data"
type Query {
    "Get a list of modding applications (accessed via API keys)"
    applications: [ApiApplication!]
    "Get a list of the current user's ignored users."
    blockedAuthors: [User!] @deprecated(reason: "This endpoint will be replaced with ignored_users")
    "Get a list of the current user's blocked tags."
    blockedTags: [LegacyTag!]
    "Get a list of categories"
    categories(
        "Game ID"
        gameId: Int,
        "If true, include all global categories"
        global: Boolean
    ): [Category!]
    "Get a category by ID"
    category(
        "Category ID"
        id: ID!
    ): Category
    "Get a collection by slug"
    collection(
        """

        Specifies game domain. Will return a NOT_FOUND
        response if invalid domain is passed.
        """
        domainName: String,
        "Unique slug for a collection"
        slug: String,
        "Overrides adult content in user preferences"
        viewAdultContent: Boolean
    ): Collection!
    "Get a list of Games containing 1 or more collections with the collection counts"
    collectionGames: [Game!]
    "Get a revision by collection slug and revision number"
    collectionRevision(
        """

        Specifies game domain. Will return a NOT_FOUND
        response if invalid domain is passed.
        """
        domainName: String,
        """

        Revision number for collection.
        If null, will return the latest published revision for this collection
        """
        revision: Int,
        "Unique slug for a collection"
        slug: String,
        "Overrides adult content in user preferences"
        viewAdultContent: Boolean
    ): CollectionRevision!
    "Get a pre-signed upload URL for B2"
    collectionRevisionUploadUrl: PresignedUrl!
    "Get a list of collections"
    collections(
        "Filters the collections to a specific category. DEPRECATED: Prefer to use filter."
        categoryId: Int,
        count: Int,
        "Filter and aggregate by specified facets"
        facets: CollectionsFacet,
        "Filter which restricts results and facets."
        filter: CollectionsUserFilter,
        "Filters the collections to a specific game. DEPRECATED: Prefer to use filter."
        gameDomain: String,
        "Filters the collections to a specific game. DEPRECATED: Prefer to use filter."
        gameId: Int,
        offset: Int,
        "Filter which restricts results but not facets."
        postFilter: CollectionsUserFilter,
        """

        Alters the sorting column used for this query. Available
        fields are: `['listed_at', 'endorsements_count', 'latest_published_revision_rating', 'total_downloads',
        'listed_at', 'name', 'created_at', 'updated_at', 'recent_rating', 'overall_rating']`
        """
        sortBy: String,
        "Alters the sorting direction used for this query"
        sortDirection: String,
        "Filters the collections to a specific user. DEPRECATED: Prefer to use filter."
        userId: Int,
        "Overrides adult content in user preferences"
        viewAdultContent: Boolean,
        "Shows discarded collections (permission required)"
        viewDiscarded: Boolean,
        "Shows listed collections"
        viewListed: Boolean,
        "Shows moderated collections (permission required)"
        viewUnderModeration: Boolean,
        "Shows unlisted collections (permission required)"
        viewUnlisted: Boolean
    ): CollectionPage!
    "Get a list of collections"
    collectionsV2(
        count: Int,
        "Filter and aggregate by specified facets."
        facets: CollectionsFacet,
        "Filter which restricts results and facets."
        filter: CollectionsSearchFilter,
        offset: Int,
        "Filter which restricts results but not facets."
        postFilter: CollectionsSearchFilter,
        sort: [CollectionsSearchSort!],
        "View collections which you have blocked (e.g. via blocking authors)"
        viewUserBlockedContent: Boolean
    ): CollectionPage!
    "Get a comment by its ID."
    comment(
        "The database ID for this comment."
        commentId: ID!
    ): Comment!
    "Get a comment thread by its ID."
    commentThread(
        "The database ID for this comment thread."
        commentThreadId: ID!
    ): CommentThread!
    "Get a list of unread warnings for a user"
    currentWarnings: UserWarnings!
    "Gets an external video."
    externalVideo(
        "The external video URL."
        url: String!
    ): ExternalVideo!
    "Gets a user's favourite games"
    favouriteGames: [Game!]
    "Get Mod FileHash by md5"
    fileHash(
        "MD5 file hashes for retrieving files"
        md5: String!
    ): [FileHash!]!
    "Get a list of FileHashes"
    fileHashes(
        "Array of MD5 file hashes for retrieving files in bulk"
        md5s: [String!]!
    ): [FileHash!]
    "Get a Game by ID or domain name"
    game(
        "Game domain name to retrieve game for"
        domainName: String,
        "Game ID to retrieve game for"
        id: ID
    ): Game
    "Get the current artwork schemas."
    gameArtwork: GameArtwork
    "Get a list of Games"
    games(
        count: Int,
        "Filter and aggregate by specified facets"
        facets: GamesFacet,
        "Filter which restricts results and facets."
        filter: GamesSearchFilter,
        offset: Int,
        "Filter which restricts results but not facets."
        postFilter: GamesSearchFilter,
        sort: [GamesSearchSort!]
    ): GamePage!
    "Get a list of the current user's ignored users."
    ignoredUsers: [User!]
    "Get a list of the current user's ignored users."
    legacyBlockedAuthors: [User!] @deprecated(reason: "This is a legacy endpoint and should not be used.")
    "Get a list of mod using composite ids, with paging"
    legacyMods(
        count: Int,
        "Mod ID (Legacy format)"
        ids: [CompositeIdInput!]!,
        offset: Int
    ): ModPage!
    "Get a list of mods by domain_name and id, with paging"
    legacyModsByDomain(
        count: Int,
        "Get mod by legacy ID format"
        ids: [CompositeDomainWithIdInput!]!,
        offset: Int
    ): ModPage!
    "Get a list of media items (Images or Videos)"
    media(
        count: Int,
        "Filter and aggregate by specified facets"
        facets: MediaFacet,
        filter: MediaSearchFilter,
        offset: Int,
        postFilter: MediaSearchFilter,
        sort: [MediaSearchSort!],
        "View media items which you have blocked (e.g. via blocking authors)"
        viewUserBlockedContent: Boolean
    ): MediaUnionPage!
    "Get a list of users that have endorsed a mod. Will return a maximum of 100 items per page."
    modEndorsers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Mod UID to retrieve endorsers for"
        modUid: ID!
    ): ModEndorserConnection!
    "Get a list of mod files"
    modFiles(
        "Game ID for retrieving mods in bulk"
        gameId: ID!,
        "Mod ID for retrieving mods in bulk"
        modId: ID!
    ): [ModFile!]!
    "Get a list of mod files by uid"
    modFilesByUid(
        count: Int,
        offset: Int,
        "List of Mod File UIDs (Not IDs) for retreiving mods in bulk"
        uids: [ID!]!
    ): ModFilePage!
    "Get a Moderation Reason by ID"
    moderationReason(
        "The database ID for this moderation reason."
        id: ID!
    ): ModerationReason
    "Get a list of Moderation Reasons"
    moderationReasons: [ModerationReason!]
    "Get a list of moderation warnings"
    moderationWarnings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter by a specific category"
        category: [ModerationWarningCategoryEnum!],
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): ModerationWarningConnection
    "Get a list of mods, with paging"
    mods(
        count: Int,
        "Filter and aggregate by specified facets"
        facets: ModsFacet,
        filter: ModsFilter,
        offset: Int,
        postFilter: ModsFilter,
        sort: [ModsSort!],
        "View hidden mods that you are the uploader for (default: true)"
        viewUploaderHidden: Boolean,
        "View mods which you have blocked (e.g. via blocking tags or authors)"
        viewUserBlockedContent: Boolean
    ): ModPage!
    "Get a list of mods by uid, with paging"
    modsByUid(
        count: Int,
        offset: Int,
        "List of Mod UIDs (Not IDs) for retreiving mods in bulk"
        uids: [ID!]!
    ): ModPage!
    "Get a list of collections that the current user has access to view"
    myCollections(
        "Filters the collections to a specific category."
        categoryId: Int @deprecated(reason: "DEPRECATED: Prefer to use filter."),
        count: Int,
        "Filter and aggregate by specified facets"
        facets: CollectionsFacet,
        "Filter which restricts results and facets."
        filter: CollectionsFilter,
        "Filters the collections to a specific game."
        gameDomain: String @deprecated(reason: "DEPRECATED: Prefer to use filter."),
        "Filters the collections to a specific game."
        gameId: Int @deprecated(reason: "DEPRECATED: Prefer to use filter."),
        offset: Int,
        "Filter which restricts results but not facets."
        postFilter: CollectionsFilter,
        "Alters the sorting column used for this query"
        sortBy: String,
        "Alters the sorting direction used for this query"
        sortDirection: String,
        "Overrides adult content in user preferences"
        viewAdultContent: Boolean,
        "Shows moderated collections (permission required)"
        viewUnderModeration: Boolean,
        "Shows unlisted collections (permission required)"
        viewUnlisted: Boolean
    ): CollectionPage!
    "retrieves all news articles."
    news(
        count: Int,
        "Filters the News to a specific game."
        gameId: Int,
        "Filters the News to a specific news category."
        newsCategory: NewsCategoryEnum,
        offset: Int
    ): NewsPage!
    "Get a list of opted in mods for this user"
    optedInMods(
        "ID of account for filtering"
        accountId: Int!
    ): OptedInMods!
    "Get the personal API access key for a current user"
    personalApiKey: ApiKey
    "Get a list of user preferences for the current user"
    preferences: Preference
    "Get a private message URL"
    privateMessageUrl(
        "Nexusmods ID of user to message"
        id: ID!
    ): String
    "Get a pre-signed upload URL. You must supply EITHER mimeType (preferred) or filename."
    requestMediaUploadUrl(
        "Local filename of the file to be uploaded. DEPRECATED- prefer mimeType."
        filename: String,
        "MIME type of the file to be uploaded."
        mimeType: String
    ): PresignedUrl!
    "Search comments by filter and sort criteria"
    searchComments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CommentsSearchFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        sort: [CommentsSearchSort!]
    ): CommentSearchResultConnection!
    "Get the urls for running a speedtest to diagnose download issues"
    speedtestUrls: [SpeedtestUrl!]!
    "Get a tag by ID"
    tag(
        "ID of Tag Category to find"
        id: ID!
    ): Tag
    "Get all tag categories"
    tagCategories: [TagCategory!]
    "Get a tag category by ID"
    tagCategory(
        "ID of Tag Category to find"
        id: ID!
    ): TagCategory
    "Get a list of tags"
    tags(
        "Filter tags by a specific category ID"
        categoryId: Int,
        "Filter tags by a specific game ID"
        gameId: Int,
        "If true, will includes discarded tags"
        includeDiscarded: Boolean,
        "If true, will include all global tags"
        includeGlobal: Boolean
    ): [Tag!]
    "Get a list of transactions, with paging and filtering"
    transactions(
        """

        Includes transactions involving this
        Account's ID
        """
        accountId: Int,
        """

        Includes transactions involving this
        Bank's ID
        """
        bankId: Int,
        "Column used for sorting"
        orderColumn: String,
        """

        Direction for sorting.
        'asc' or 'desc' are the only valid options
        """
        orderDir: String,
        """

        Number of elements to return per
        page
        """
        perPage: Int,
        "Filter transactions to return"
        search: String,
        "Offset for pagination"
        start: Int
    ): TransactionList!
    "Get a list of uploads"
    uploads(
        "The database ID for this ModFile."
        fileId: Int,
        "Filter uploads"
        filter: String,
        "The database ID for this Game."
        gameId: Int,
        "The database ID for this ModUpload."
        id: String,
        "The database ID for this Mod."
        modId: Int,
        "Column used for sorting"
        orderColumn: String!,
        """

        Direction for sorting.
        'asc' or 'desc' are the only valid options
        """
        orderDir: String!,
        """

        Number of elements to return per
        page
        """
        perPage: Int!,
        "Filter uploads"
        search: String,
        """

        For offset-based pagination. Indicates
        the first element to start returning values from
        """
        start: Int!,
        "Only return specific types of uploads"
        uploadType: String,
        "The database ID for this User."
        userId: Int
    ): UploadList!
    "Get user by id"
    user(
        "User ID of user to find"
        id: Int!
    ): User
    "Get user by username"
    userByName(
        "Username of user to find"
        name: String!
    ): User
    "Get a list of user donation preferences."
    userDonationPreferences: LegacyUserDonationPreferences
    "Get monthly summary report for a specific user"
    userMonthlyReport(
        "Account ID"
        accountId: Int!,
        "Month report was generated"
        month: Int!,
        "Year report was generated"
        year: Int!
    ): UserMonthlyReport!
    "Get a specific report for a specific user"
    userMonthlyReportById(
        "Account ID"
        accountId: Int!,
        "Donation Report ID"
        reportId: Int!
    ): UserMonthlyReport!
    "Get monthly summary report for a specific user"
    userMonthlySummary(
        "Account ID"
        accountId: Int!
    ): UserMonthlySummary!
    "Get a list of Users"
    users(
        count: Int,
        "Filter which restricts results."
        filter: UsersSearchFilter,
        offset: Int,
        sort: [UsersSearchSort!]
    ): UserPage!
    "Get a list of wallets, with paging and filtering"
    wallets(
        "Column used for sorting"
        orderColumn: String,
        """

        Direction for sorting.
        'asc' or 'desc' are the only valid options
        """
        orderDir: String,
        """

        Number of elements to return per
        page
        """
        perPage: Int,
        "Used to filter specific accounts"
        search: String,
        """

        For offset-based pagination. Indicates
        the first element to start returning values from
        """
        start: Int
    ): WalletList! @deprecated(reason: "Legacy Query. This endpoint may change or become unstable in future updates.")
}

"A Rating"
type Rating implements Node {
    "ID of the object."
    id: ID!
    "Polymorphic ID of the entity being rated"
    modelId: Int!
    """

    Polymorphic type of the entity being
    rated
    """
    modelType: String!
    "Rating value"
    rating: String!
    "ID of the user that created this rating"
    userId: Int!
}

"Autogenerated return type of RejectModerationFixMutation."
type RejectModerationFixMutationPayload {
    "Return the moderation fix object"
    moderationFix: ModerationFix!
    "Returns trus if the fix was rejected"
    success: Boolean!
}

"Autogenerated return type of RemoveCommentLikeMutation."
type RemoveCommentLikeMutationPayload {
    "The comment that had its like removed."
    comment: Comment!
}

"Autogenerated return type of RemoveFavouriteGameMutation."
type RemoveFavouriteGameMutationPayload {
    "True if the favourite was successfully removed"
    success: Boolean!
}

"Autogenerated return type of RemoveHeaderImageFromCollectionMutation."
type RemoveHeaderImageFromCollectionMutationPayload {
    "Returns true when image was removed successfully."
    success: Boolean!
}

"Autogenerated return type of RemoveImageFromCollectionMutation."
type RemoveImageFromCollectionMutationPayload {
    "Returns true when image is removed successfully."
    success: Boolean!
}

"Autogenerated return type of RemoveKudosMutation."
type RemoveKudosMutationPayload {
    "True if the user has successfully had kudos removed"
    success: Boolean!
}

"Autogenerated return type of RemoveTagFromCollectionMutation."
type RemoveTagFromCollectionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of RemoveTileImageFromCollectionMutation."
type RemoveTileImageFromCollectionMutationPayload {
    "Returns true when image is removed successfully."
    success: Boolean!
}

"Autogenerated return type of RemoveVideoFromCollectionMutation."
type RemoveVideoFromCollectionMutationPayload {
    "Returns true when video is removed successfully."
    success: Boolean!
}

"Autogenerated return type of ReorderItem."
type ReorderItemPayload {
    "The item that was moved."
    item: Reorderable
}

"Autogenerated return type of ReorderPinnedCommentsMutation."
type ReorderPinnedCommentsMutationPayload {
    "Pinned comments in a new order."
    comments: [Comment!]!
}

"Autogenerated return type of RestoreCommentMutation."
type RestoreCommentMutationPayload {
    "The comment that was restored."
    comment: Comment!
}

"Autogenerated return type of RetractRevisionMutation."
type RetractRevisionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"A reason for which a revision has been retracted."
type RetractionReason {
    "An immutable revision of a collection"
    collectionRevisionId: Int!
    "Time of when this retraction reason was first created."
    createdAt: DateTime!
    "The database ID for this retraction reason."
    id: Int!
    "User-provided reason for this retraction"
    reason: String!
    "Time of when this retraction reason was last updated."
    updatedAt: DateTime!
}

"A speedtest URL"
type SpeedtestUrl {
    "Description of this speedtest URL"
    description: String
    "URL of the resource"
    location: String
    "Tag of the resource"
    tag: String
    "Resource name of this speedtest URL"
    title: String
}

"Autogenerated return type of SubmitModerationFixMutation."
type SubmitModerationFixMutationPayload {
    "Return moderation fix object"
    moderationFix: ModerationFix!
    "Returns true if this fix was created successfully"
    success: Boolean!
}

"A supporter image"
type SupporterImage implements Node {
    "Whether comments are allowed on the image."
    allowComments: Boolean
    "Whether ratings are allowed on the image."
    allowRating: Boolean
    "A caption for this image"
    caption: String!
    "An image category"
    category: ImageCategory!
    "Time of when this supporter_image was first created."
    createdAt: DateTime!
    "A detailed description of this image"
    description: String!
    "Game this image belongs to"
    game: Game!
    "ID of the object."
    id: ID!
    "Status of this image"
    mediaStatus: MediaStatus!
    "Name of the image file"
    name: String!
    "Uploader of this image"
    owner: User!
    "Rating of this image"
    rating: Int!
    "URL of the site this image is hosted on"
    siteUrl: String!
    "URL of the thumbnail of this image"
    thumbnailUrl: String!
    "A title for this image"
    title: String
    "URL of this image"
    url: String!
    "True if the viewer (current user) has ignored this image's author"
    viewerBlocked: Boolean!
    "View count of this image"
    views: Int!
}

"""

The definition of a Tag Object. Deprecated.
Will be removed in a future release in favour of domain specific tag queries/mutations
"""
type Tag {
    "If true, this Tag is intended for adult content"
    adult: Boolean!
    "Category that this tag belongs to"
    category: TagCategory
    "Time of when this tag was first created."
    createdAt: DateTime!
    "Time of when this tag was discarded."
    discardedAt: DateTime
    "List of games that this tag is for"
    games: [Game!]
    "If true, this Tag is global and not intended for a specific game"
    global: Boolean!
    "The database ID for this tag."
    id: ID!
    "Name of this tag"
    name: String!
    "Number of tagged entities for this tag"
    taggablesCount: Int!
    "Time of when this tag was last updated."
    updatedAt: DateTime!
}

"""

The definition of a Tag Category Object. Deprecated.
Will be removed in a future release in favour of domain specific tag queries/mutations
"""
type TagCategory {
    "Time of when this tag category was first created."
    createdAt: DateTime!
    "Time of when this tag category was discarded."
    discardedAt: DateTime
    "The database ID for this tag category."
    id: ID!
    "Name of this Tag Category"
    name: String!
    "List of tags in this catgeory"
    tags: [Tag!]
    "Time of when this tag category was last updated."
    updatedAt: DateTime!
}

"Autogenerated return type of TrackModMutation."
type TrackModMutationPayload {
    "True if the request to track the mod was successful, or if the mod was already tracked."
    success: Boolean!
    "Tracked mod entry."
    trackedMod: TrackedMod!
}

"Autogenerated return type of TrackUserMutation."
type TrackUserMutationPayload {
    "True if the request to track the user was successful"
    success: Boolean!
}

"Represents a user's tracking of a mod"
type TrackedMod {
    "The ID of the game that the tracked mod belongs to"
    gameId: ID!
    "The ID of the mod that is tracked"
    modId: ID!
    "The ID of the tracking user"
    userId: ID!
}

"A transaction"
type Transaction {
    "Amount of DP in this transaction"
    amount: Int!
    "Time of when this transaction was first created."
    createdAt: String!
    "Account/Bank that DP is being sent to"
    creditor: String @deprecated(reason: "Use 'creditorEntity' instead")
    "Account/Bank that DP is being sent to"
    creditorEntity: PaymentEntity
    "Account/Bank that DP is being taken from"
    debitor: String @deprecated(reason: "Use 'debitorEntity' instead")
    "Account/Bank that DP is being taken from"
    debitorEntity: PaymentEntity
    "The database ID for this transaction."
    id: Int!
    "Descriptive label for this transaction"
    label: String!
    "Type of transaction E.g. 'refund', 'purchase' etc"
    type: String!
}

"A list of transactions"
type TransactionList {
    "Number of transactions being filtered"
    filteredCount: Int!
    "Total number of transactions in the system"
    totalCount: Int!
    "List of Transactions"
    transactions: [Transaction!]
}

"Autogenerated return type of UnblockModsFromEarningDpMutation."
type UnblockModsFromEarningDpMutationPayload {
    "True if the mods were successfully unblocked"
    success: Boolean!
}

"Autogenerated return type of UnblockTagMutation."
type UnblockTagMutationPayload {
    "If true, the tag is unblocked."
    success: Boolean!
}

"Autogenerated return type of UnblockUserMutation."
type UnblockUserMutationPayload {
    "If true, the user is unignored."
    success: Boolean!
}

"Autogenerated return type of UnignoreUserMutation."
type UnignoreUserMutationPayload {
    "If true, the user is unignored."
    success: Boolean!
}

"Autogenerated return type of UnlistCollectionMutation."
type UnlistCollectionMutationPayload {
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of UnpinCommentMutation."
type UnpinCommentMutationPayload {
    "The comment that was unpinned."
    comment: Comment!
}

"Autogenerated return type of UntrackModMutation."
type UntrackModMutationPayload {
    "True if the request to un-track the mod was successful, or if the mod was not being tracked."
    success: Boolean!
}

"Autogenerated return type of UntrackUserMutation."
type UntrackUserMutationPayload {
    "True if the request to stop tracking the user was successful"
    success: Boolean!
}

"Autogenerated return type of UpdateAboutMeMutation."
type UpdateAboutMeMutationPayload {
    "True if the bio was successfully updated"
    success: Boolean!
}

"Autogenerated return type of UpdateChangelogMutation."
type UpdateChangelogMutationPayload {
    "Updated Changelog ID"
    changelogId: Int!
    "Success Boolean"
    success: Boolean!
}

"Autogenerated return type of UpdateCollectionBugReportMutation."
type UpdateCollectionBugReportMutationPayload {
    "Collection bug report that was updated"
    collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of UpdateCommentMutation."
type UpdateCommentMutationPayload {
    "The comment that was updated."
    comment: Comment!
}

"Autogenerated return type of UpdateCountryMutation."
type UpdateCountryMutationPayload {
    "True if the country was successfully updated"
    success: Boolean!
}

"Autogenerated return type of UpdateGameMutation."
type UpdateGameMutationPayload {
    "If true, the game was updated"
    success: Boolean!
}

"Autogenerated return type of UpdateRevisionMutation."
type UpdateRevisionMutationPayload {
    "The revision ID that was updated"
    revisionId: Int!
    "If true, the revision was updated"
    success: Boolean!
}

"Autogenerated return type of UpdateTagMutation."
type UpdateTagMutationPayload {
    "Success Boolean"
    success: Boolean!
    "Updated Collection Tag"
    tag: Tag!
}

"Autogenerated return type of UpdateUserDonationPreferences."
type UpdateUserDonationPreferencesPayload {
    "If true, the user's preferences were updated."
    success: Boolean!
    "If successful, the user's updated donation preferences."
    userDonationPreferences: LegacyUserDonationPreferences
}

"Autogenerated return type of UploadAttachmentMutation."
type UploadAttachmentMutationPayload {
    "The uploaded file returns a signed_id that can be used to attach to objects."
    attachment: Attachment!
}

"Autogenerated return type of UploadGameArtworkV2Mutation."
type UploadGameArtworkV2MutationPayload {
    "If true, the hero image was updated."
    successHero: Boolean!
    "If true, the thumbnail image was updated."
    successThumbnail: Boolean!
    "If true, the tile image was updated."
    successTile: Boolean!
}

"A list of upload"
type UploadList {
    "Number of uploads being filtered"
    filteredCount: Int!
    "Total number of uploads"
    totalCount: Int!
    "List of uploads"
    uploads: [ModUpload!]
}

"A Nexus Mods user"
type User {
    "User's bio"
    about: String
    "The avatar for this user"
    avatar: String!
    "If true, this user has been banned"
    banned: Boolean!
    "Timestamp at which user's new mods were blocked from earning DP"
    blockedFromOptingInModsAt: DateTime
    """

    Number of collections uploaded by this user.
    This does not include unlisted or moderated collections.
    """
    collectionCount: Int!
    "The number of mods this user has contributed to"
    contributedModCount: Int!
    "ISO Country Code"
    country: String
    "If true, this user has been deleted"
    deleted: Boolean!
    "If true, this user has enabled donations on their profile page"
    donationsEnabled: Boolean!
    "If false, this user has specifically opted-out of the DP system. By default, all users are opted in."
    dpOptedIn: Boolean!
    "The user's email address. Users can only access their own protected data."
    email: String!
    "Number of mod endorsements given by this user"
    endorsementsGiven: Int!
    "The number of full page notifications this user has been served in the past."
    fullPageNotificationCount: Int
    """

    If true, the viewer (current user) has
    given kudos to this user.
    """
    hasGivenKudos: Boolean!
    """

    Number of images uploaded by this user.
    This does not include moderated images.
    """
    imageCount: Int!
    "The user's last known IP Address. Users can only access their own protected data."
    ipAddress: String
    """

    If true, the viewer (current user) has
    blocked this user.
    """
    isBlocked: Boolean!
    """

    If true, the viewer (current user) is
    tracking this user.
    """
    isTracked: Boolean!
    "Date the user joined"
    joined: DateTime!
    "The number of 'kudos' given to this user"
    kudos: Int!
    "Date the user was last active"
    lastActive: DateTime
    "Legacy roles for this user. Returns an array of roles. E.g. \"[SiteProgrammer, QA Tester]\""
    legacyRoles: [String!]!
    "The database ID for this user."
    memberId: Int!
    "Membership status for this user. Returns an array of roles. E.g. all users are \"member\""
    membershipRoles: [String!]!
    "The analytics for the user's mods, grouped by month"
    modAnalyticsByMonth(
        "The affiliation to filter by"
        affiliation: ModAffiliation,
        "The page number to retrieve"
        page: Int,
        "The number of results per page"
        pageSize: Int,
        "The field to sort by"
        sortBy: ModAnalyticsByMonthSortBy,
        "The direction to sort by"
        sortDirection: SortDirection
    ): ModAnalyticsByMonthPage!
    "The analytics for the user's mods for a specific month"
    modAnalyticsForMonth(
        "The affiliation to filter by"
        affiliation: ModAffiliation,
        "The month to retrieve analytics for"
        month: Int!,
        "The page number to retrieve"
        page: Int,
        "The number of results per page"
        pageSize: Int,
        "Search term to filter mods by"
        query: String,
        "The field to sort by"
        sortBy: ModAnalyticsForMonthSortBy,
        "The direction to sort by"
        sortDirection: SortDirection,
        "The year to retrieve analytics for"
        year: Int!
    ): ModAnalyticsForMonthPage!
    """

    Number of mods uploaded by this user.
    This does not include hidden, moderated or unpublished mods.
    """
    modCount: Int!
    "The number of moderation warnings this user has been served in the past."
    moderationHistoryCount: Int
    "JWT token for submitting moderation reports"
    moderationJwt: String!
    "A list of mods blocked from earning dp"
    modsBlockedFromEarningDp(
        "Number of mods to return"
        count: Int,
        "Number of mods to skip"
        offset: Int
    ): BlockedModsPage!
    "The user's username."
    name: String!
    "The number of mods this user has uploaded"
    ownedModCount: Int!
    "Email address used for PayPal donations. Users can only access their own protected data."
    paypal: String
    "The number of forum posts by this user"
    posts: Int!
    """

    If true, this user is a
    recognised mod author
    """
    recognizedAuthor: Boolean!
    "Roles for this user. Returns an array of roles. E.g. \"[Admin, Moderator]\""
    roles: [String!]!
    """

    If true, this user has opted to
    show their activity feed on their user profile page
    """
    showActivityFeed: Boolean!
    """

    If true, this user has opted to
    show the date they were last active on their user profile page
    """
    showLastActive: Boolean!
    "Number of unique mod downloads on this users mods"
    uniqueModDownloads: Int!
    """

    Date the user last
    changed their username. Only users can access their own protected data.
    """
    usernameLastChangedAt: DateTime
    """

    Number of videos uploaded by this user.
    This does not include moderated videos.
    """
    videoCount: Int!
    "Whether the viewer has blocked the content owner."
    viewerHasBlocked: Boolean
    "Whether the viewer has ignored the content owner."
    viewerHasIgnored: Boolean!
    "Number of profile views"
    views: Int!
}

"The connection type for User."
type UserConnection {
    "A list of edges."
    edges: [UserEdge]
    "A list of nodes."
    nodes: [User]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "Total # of objects returned from this Plural Query"
    totalCount: Int!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User
}

"""

Monthly detailed report for for a particular user/account
on how much DP/downloads they have received for which mod/game
"""
type UserMonthlyReport {
    "List of entries in this report"
    entries: [UserMonthlyReportEntry!]!
    "Type of report"
    reportType: DonationReport!
    "A Nexus Mods user"
    user: User
    "The database ID for this user."
    userId: Int!
}

"A more detailed entry for UserMonthlyReport, with a breakdown for a specific month for each mod"
type UserMonthlyReportEntry {
    "A Nexus Mods user"
    author: User
    "Number of authors that give this user DP"
    authorCount: Int
    "The database ID for this user."
    authorId: Int
    """

    Total DP value from all authors this user gets DP from, including DP not shared with this
    user.
    """
    authorValue: Int
    "A Game"
    game: Game
    "The database ID for this game."
    gameId: Int
    "A mod"
    mod: Mod
    "Number of mods that this user appears in"
    modCount: Int
    "The database ID for this mod."
    modId: Int
    "Total DP value from all mods this user appears in, including DP not shared with this user."
    modValue: Int
    "Month that this entry is for"
    month: Int!
    "Ratio of how much of the DP earned for a mod or author is given to this user"
    ratio: Float!
    "The database ID for this donation report."
    reportId: Int!
    "Opt-in status of this mod"
    status: Int!
    "Total DP granted to this user in this entry"
    value: Int!
    "Year that this entry is for"
    year: Int!
}

"Monthly summary for for a particular user/account on how much DP/downloads they have received"
type UserMonthlySummary {
    "List of summary report entries for this month"
    entries: [UserMonthlySummaryEntry!]!
    "A Nexus Mods user"
    user: User!
    "The database ID for this user."
    userId: Int!
}

"An entry for UserMonthlySummary, with a breakdown for a specific month"
type UserMonthlySummaryEntry {
    "Number of mods that this user appears in"
    modCount: Int!
    "Total DP value from all mods this user appears in, including DP not shared with this user."
    modValue: Int!
    "Month that this entry is for"
    month: Int!
    "Type of report"
    reportType: DonationReport!
    "Total DP granted to this user in this entry"
    value: Int!
    "Year that this entry is for"
    year: Int!
}

type UserPage {
    "Facets available, if supported for this query and requested."
    facets: [NodesFacet!]
    "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
    facetsData: JSON
    "Nodes for pagination"
    nodes: [User!]!
    "Number of nodes returned by this query"
    nodesCount: Int!
    "Facets available, if supported for this query and requested."
    nodesFacets: [NodesFacet!]
    "String representation of the filter query used to locate the nodes."
    nodesFilter: String
    "Total number of collections found."
    totalCount: Int!
}

"A return type for the current warnings query"
type UserWarnings {
    "List of unread global notices"
    unreadGlobalNotices: [GlobalNotice!]!
    "List of unread warnings"
    unreadWarnings: [ModerationWarning!]!
}

"A video"
type Video implements Node {
    "Whether comments are allowed on the video."
    allowComments: Boolean
    "Whether ratings are allowed on the video."
    allowRating: Boolean
    "An video category"
    category: VideoCategory!
    "Time of when this video was first created."
    createdAt: DateTime!
    "The description of the video."
    description: String
    "Game this video belongs to"
    game: Game!
    "ID of the object."
    id: ID!
    "The URL of the video."
    link: String!
    "Status of this video"
    mediaStatus: MediaStatus!
    "Uploader of this video"
    owner: User!
    "The rating of the video."
    rating: Int!
    "URL of the site this video is hosted on"
    siteUrl: String!
    "The URL of the video thumbnail."
    thumbnailUrl: String!
    "The title of the video."
    title: String
    "True if the viewer (current user) has ignored this video's author"
    viewerBlocked: Boolean!
    "The number of views the video has."
    views: Int!
}

"An video category"
type VideoCategory {
    "Unix timestamp of category creation"
    date: Int
    "The database ID for this video category."
    id: ID!
    "Name of this category"
    name: String!
}

"A list of wallets. Users must have admin access."
type WalletList {
    "Number of wallets being filtered"
    filteredCount: Int!
    "Total number of wallets in the system"
    totalCount: Int!
}

"Autogenerated return type of WriteFullPageNotificationToUserMutation."
type WriteFullPageNotificationToUserMutationPayload {
    "Full page notification created successfully"
    success: Boolean
}

"Acceptable bug report closure reasons"
enum BugReportClosureReason {
    "None"
    none
    "Not a bug"
    not_a_bug
    "Resolved"
    resolved
    "Wont fix"
    wont_fix
}

"Moderation Status of a Bug Report"
enum BugReportModerationStatus {
    "Hidden"
    hidden
    "None"
    none
}

"Acceptable bug report statuses"
enum BugReportStatus {
    "Closed"
    closed
    "Open"
    open
}

"Available collection statuses"
enum CollectionStatus {
    "Discarded"
    discarded
    "Publicly visible"
    listed
    "Under moderation"
    under_moderation
    "Does not appear in lists"
    unlisted
}

"Enum for available moderation states: \"none\", \"hidden\", \"locked\""
enum CommentModerationStatus {
    "The comment cannot be viewed."
    hidden
    "The comment cannot be interacted with."
    locked
    "The comment is not under moderation."
    none
}

"Enum for available thread moderation states: \"none\", \"locked\""
enum CommentThreadModerationStatus {
    "The comment thread cannot be interacted with."
    locked
    "The comment thread is not under moderation."
    none
}

"Report Type defined by the Wallet app."
enum DonationReport {
    "Interaction-based, game-adjusted report"
    I20_GAME_ADJUSTED
    "Interaction-based report with DP bucketed by game"
    I20_GAME_POOLS
    "Unique Download report"
    UNIQUE_DOWNLOADS
}

"Supported external video platforms."
enum ExternalVideoPlatform {
    "https://www.youtube.com"
    youtube
}

"Filter comparison operators for elastic search queries."
enum FilterComparisonOperator {
    EQUALS
    "Greater than"
    GT
    "Greater than or equal to"
    GTE
    "Less than"
    LT
    "Less than or equal to"
    LTE
    "Matches if all terms in the value are present (in any order). No wildcarding, though stems may match."
    MATCHES
    NOT_EQUALS
    "Matches if all terms in the value are present (in any order), with leading/trailing wildcards applied."
    WILDCARD
}

"Filter comparison equals and matches operators for elastic search queries."
enum FilterComparisonOperatorEqualsMatches {
    EQUALS
    "Matches if all terms in the value are present (in any order). No wildcarding, though stems may match."
    MATCHES
    NOT_EQUALS
}

"Filter comparison equals and matches operators for elastic search queries."
enum FilterComparisonOperatorEqualsWildcard {
    EQUALS
    NOT_EQUALS
    "Matches if all terms in the value are present (in any order), with leading/trailing wildcards applied."
    WILDCARD
}

"Filter logical operators for elastic search queries."
enum FilterLogicalOperator {
    "Logical AND"
    AND
    "Logical OR"
    OR
}

"Formal or informal moderation warning"
enum FormalOrInformalWarning {
    FORMAL_WARNING
    INFORMAL_WARNING
}

"Schema for managing game artwork"
enum GameArtworkSchema {
    V1
    V2
}

"Available image types"
enum ImageTypes {
    gallery
    header
    tile
}

"Available media statuses"
enum MediaStatus {
    "Hidden"
    hidden
    "Publicly visible"
    published
    "Under moderation"
    under_moderation
}

"The affiliation of user to a mod"
enum ModAffiliation {
    "A contributor to the mod"
    CONTRIBUTOR
    "The owner of the mod"
    OWNER
}

"Attributes to sort by for mod analytics by month"
enum ModAnalyticsByMonthSortBy {
    "Sort by date"
    DATE
    "Sort by total downloads"
    TOTAL_DOWNLOADS
    "Sort by total unique downloads"
    UNIQUE_DOWNLOADS
}

"Attributes to sort by for mod analytics for month"
enum ModAnalyticsForMonthSortBy {
    "Sort by total downloads"
    TOTAL_DOWNLOADS
    "Sort by total unique downloads"
    UNIQUE_DOWNLOADS
}

"Used to flag a mod file as a main, old or archived file."
enum ModFileCategory {
    ARCHIVED
    MAIN
    MISCELLANEOUS
    OLD_VERSION
    OPTIONAL
    REMOVED
    UPDATE
}

"""

Used to define the source of a mod. Useful for informing Collections how to retrieve
mods.
"""
enum ModSource {
    "A general url to find the mod (further instructions may be provided)"
    browse
    "Mod files are included in the collection asset file, and do not need to be acquired separately"
    bundle
    "A direct url to download from"
    direct
    "Manual instructions for installing the mod"
    manual
    "The Nexus website"
    nexus
}

"Moderatable Model Types"
enum Moderatable {
    "A nexusmods Collection of Mods"
    Collection
}

"Available moderation fix statuses"
enum ModerationFixStatus {
    "An Admin has accepted this fix"
    accepted
    "An Admin has rejected this fix"
    rejected
    "Awaiting an Admin's approval"
    submitted
}

"Moderation restriction types"
enum ModerationRestrictions {
    ADD_VIDEOS
    BLOCK_PM
    COMMENT_FILE
    ENDORSE_MEDIA
    ENDORSE_MOD
    FILE_DOWNLOAD
    FILE_UPLOAD
    IMAGE_UPLOAD
    MOD_TOOLS
    POST
}

"Moderation warning category types."
enum ModerationWarningCategoryEnum {
    AUTOMATIC_MESSAGE
    BAN
    CLOSE_ACCOUNT
    FORMAL_WARNING
    INFORMAL_WARNING
    MANUAL_MESSAGE
    UNBAN
}

"Moderation warning restriction feature types."
enum ModerationWarningRestrictionFeatureEnum {
    AddVideos
    BlockPM
    ChatBan
    CommentFile
    EndorseImage
    EndorseMod
    EndorseVideos
    FileDownload
    FileUpload
    ImageUpload
    ModTools
    Post
}

"Forum news articles type."
enum NewsCategoryEnum {
    COMPETITIONS
    FEATURES
    GAME_NEWS
    INTERVIEWS
    MOD_NEWS
    SITE_NEWS
}

"Amount of comments per page."
enum PreferencesCommentsEnum {
    COMMENTS_10
    COMMENTS_20
    COMMENTS_30
    COMMENTS_40
    COMMENTS_50
}

"Default media tab."
enum PreferencesDefaultMediaTabEnum {
    NEW
    POPULAR
    RANDOM
    TRENDING
}

"Default mods tab."
enum PreferencesDefaultModsTabEnum {
    NEW
    POPULAR
    RANDOM
    TRENDING
    UPDATED
}

"Default search view."
enum PreferencesDefaultSearchViewEnum {
    COMPACT
    LIST
    STANDARD
}

"Default sorting option."
enum PreferencesDefaultSortEnum {
    BY_AUTHOR_NAME
    BY_DOWNLOADS
    BY_ENDORSEMENTS
    BY_FILE_NAME
    BY_FILE_SIZE
    BY_LAST_UPDATED_FILE
    BY_RECENT_FILES
    BY_UNIQUE_DOWNLOADS
    LAST_COMMENT
    RANDOM_SORTING
}

"Download location."
enum PreferencesDlLocationEnum {
    AMSTERDAM
    CHICAGO
    LOS_ANGELES
    MIAMI
    NEXUS_CDN
    PRAGUE
}

"Download method."
enum PreferencesDownloadMethodEnum {
    POP_UP_BOX
    SEPARATE_PAGE
}

"Image showcase."
enum PreferencesImageShowcaseEnum {
    CHOOSE_ON_PER_IMAGE_BASIS
    NOT_SET
    TURN_OFF_IMAGES
    TURN_ON_IMAGES
}

"Endorsement reminder."
enum PreferencesReminderEnum {
    DAYS_1
    DAYS_14
    DAYS_28
    DAYS_3
    DAYS_7
    NEVER
}

"Amount of results per page."
enum PreferencesResultsEnum {
    RESULTS_20
    RESULTS_40
    RESULTS_60
    RESULTS_80
}

"Search types."
enum PreferencesSearchTypeEnum {
    ALL_CONTENT
    COLLECTIONS
    GAMES
    IMAGES
    MODS
    USERS
    VIDEOS
}

"Time range values for preferences."
enum PreferencesTimeRangeEnum {
    ALL_TIME
    FOUR_WEEKS
    ONE_DAY
    ONE_WEEK
    ONE_YEAR
    TWO_WEEKS
}

"Ratable Model Types"
enum Ratable {
    "A nexusmods Collection of Mods"
    CollectionRevision
    "A Nexusmods Mod"
    Mod
}

"Rating options"
enum RatingOptions {
    abstained
    negative
    positive
}

"The relative location of an item in relation to another item."
enum ReorderLocation {
    "After the item."
    AFTER
    "Before the item."
    BEFORE
}

"Sort directions: ASC, DESC"
enum SortDirection {
    "Ascending"
    ASC
    "Descending"
    DESC
}

"Accepted Thumbnail Sizes"
enum ThumbnailSize {
    "500px width"
    large
    "385px width"
    med
    "250px width"
    small
}

"Available update policies of a file resource"
enum UpdatePolicy {
    "Use the exact specified version"
    exact
    "Use the latest version"
    latest
    "Prefer the specified version if available"
    prefer
}

"Records the outcome of the virus scan for a mod file."
enum VirusScanStatus {
    FILE_NOT_FOUND
    INTERNALLY_VERIFIED
    MANUALLY_VERIFIED
    MOD_DOES_NOT_EXIST
    NOT_SCANNED
    QUARANTINED
    QUEUED
    REPORT_ERROR
    TOO_LARGE
    VERIFIED
    WAITING_REPORT
}

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"Scalar Type to parse and handle DateTimes in iso8601 format"
scalar DateTime

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Represents untyped JSON"
scalar JSON

scalar Upload

input BaseFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Value"
    value: String!
}

input BaseFilterValueEqualsMatches {
    "Comparison operator for value."
    op: FilterComparisonOperatorEqualsMatches
    "Value"
    value: String!
}

input BaseFilterValueEqualsWildcard {
    "Comparison operator for value."
    op: FilterComparisonOperatorEqualsWildcard
    "Value"
    value: String!
}

input BaseSortValue {
    "Direction of sort."
    direction: SortDirection!
}

"A boolean value E.g. true or false"
input BooleanFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Boolean Value"
    value: Boolean!
}

input CollectionGeneralSearchFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Value"
    value: String!
}

"The JSON manifest that defines a collection"
input CollectionManifest {
    "Manifest information"
    info: CollectionManifestInfo!
    "List of mod resources for the manifest"
    mods: [CollectionManifestMod!]!
}

"The info section of the JSON manifest"
input CollectionManifestInfo {
    "The collection author's name"
    author: String!
    "The url of the author's profile"
    authorUrl: String
    "A description of the collection"
    description: String
    "The domain name of the game"
    domainName: String!
    "A list of game versions that this revision has been tested with"
    gameVersions: [String!]
    "The name of the collection"
    name: String!
    "A short summary of the collection"
    summary: String
}

"Defines a mod to be used in a collection as part of the manifest"
input CollectionManifestMod {
    "The name of the mod author"
    author: String
    "The domain name of the game for the mod"
    domainName: String!
    "The name of the mod"
    name: String!
    "Whether the mod is required for this collection"
    optional: Boolean!
    "Mod source details"
    source: CollectionManifestModSource!
    "The mod version"
    version: String!
}

"Source information for a mod (nexus or other) as part of the manifest"
input CollectionManifestModSource {
    "Does the mod includes adult content"
    adultContent: Boolean
    "File expression of the mod resource"
    fileExpression: String
    "File ID"
    fileId: Int
    "The file size in kb"
    fileSize: Int
    "Logical file name of the mod resource"
    logicalFilename: String
    "An MD5 hash of the file for verification"
    md5: String
    "Mod id"
    modId: Int
    "Type of the mod source"
    type: ModSource!
    "Update policy type"
    updatePolicy: UpdatePolicy
    "The direct url of the file"
    url: String
}

"The data payload used to create a collection revision"
input CollectionPayload {
    "Whether the collection includes adult content"
    adultContent: Boolean!
    "Collection manifest"
    collectionManifest: CollectionManifest!
    "Collection schema ID (Default: 1)"
    collectionSchemaId: Int!
}

"Facet fields specific to the Collections query."
input CollectionsFacet {
    "Facet on adult content."
    adultContent: [String!]
    "Facet on category."
    categoryName: [String!]
    "Facet on ratings."
    collectionRating: [String!]
    "Facet on status."
    collectionStatus: [String!]
    "Facet on game ID."
    gameIds: [String!]
    "Facet on game name."
    gameName: [String!]
    "Facet on game versions."
    gameVersion: [String!]
    "Facet on collection tags."
    tag: [String!]
}

"Common filter fields specific to the Collections query"
input CollectionsFilter {
    "Whether to show adult content in search results"
    adultContent: [BooleanFilterValue!]
    "Category ID"
    categoryId: [BaseFilterValue!]
    "Category name"
    categoryName: [BaseFilterValue!]
    "Collection Rating"
    collectionRating: [BaseFilterValue!]
    """

    Status of the collection. Valid values are: "unlisted",
    "under_moderation" (moderators/admins only), "discarded" (moderators/admins only).
    """
    collectionStatus: [BaseFilterValue!]
    "Nested filters."
    filter: [CollectionsFilter!]
    "Game domain name E.g. skyrim"
    gameDomain: [BaseFilterValue!]
    "Game ID"
    gameId: [BaseFilterValue!]
    "Game name E.g. Skyrim"
    gameName: [BaseFilterValue!]
    "Filter collections for specific game versions"
    gameVersion: [BaseFilterValue!]
    "Text search on name, summary and description, partial match."
    generalSearch: [CollectionGeneralSearchFilterValue!]
    "Only show collections that have a draft revision"
    hasDraftRevision: [BooleanFilterValue!]
    "Only show collections that have a published revision"
    hasPublishedRevision: [BooleanFilterValue!]
    "The mod unique identifier."
    modUid: [BaseFilterValue!]
    "Collection Name"
    name: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "The tag name, exact match."
    tag: [BaseFilterValue!]
}

"Common filter fields specific to the Collections query"
input CollectionsSearchFilter {
    "Whether to show adult content in search results"
    adultContent: [BooleanFilterValue!]
    "Category ID"
    categoryId: [BaseFilterValue!]
    "Category name"
    categoryName: [BaseFilterValue!]
    "Collection Rating"
    collectionRating: [BaseFilterValue!]
    "Collection Status"
    collectionStatus: [BaseFilterValue!]
    "Created at date"
    createdAt: [BaseFilterValue!]
    "Nested filters."
    filter: [CollectionsSearchFilter!]
    "Game domain name E.g. skyrim"
    gameDomain: [BaseFilterValue!]
    "Game ID"
    gameId: [BaseFilterValue!]
    "Game name E.g. Skyrim"
    gameName: [BaseFilterValue!]
    "Filter collections for specific game versions"
    gameVersion: [BaseFilterValue!]
    "Text search on name, summary and description, partial match."
    generalSearch: [CollectionGeneralSearchFilterValue!]
    "Only show collections that have a draft revision"
    hasDraftRevision: [BooleanFilterValue!]
    "Only show collections that have a published revision"
    hasPublishedRevision: [BooleanFilterValue!]
    "The mod unique identifier."
    modUid: [BaseFilterValue!]
    "Collection Name"
    name: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "A 30 day average of all revision ratings"
    recentRating: [FloatFilterValue!]
    "Total number of ratings given in the last 30 days"
    recentRatingCount: [IntFilterValue!]
    "The tag name, exact match."
    tag: [BaseFilterValue!]
    "Updated at date"
    updatedAt: [BaseFilterValue!]
    "Author ID"
    userId: [BaseFilterValue!]
}

"Sort fields specific to a Collections query."
input CollectionsSearchSort {
    "Created at date"
    createdAt: BaseSortValue
    "Downloads count"
    downloads: BaseSortValue
    "Endorsements count"
    endorsements: BaseSortValue
    "Overall rating"
    rating: BaseSortValue
    "Filter query relevance, works best with non wildcard queries."
    relevance: BaseSortValue
    "Updated at date"
    updatedAt: BaseSortValue
}

"Allows filtering collections by user"
input CollectionsUserFilter {
    "Whether to show adult content in search results"
    adultContent: [BooleanFilterValue!]
    "Category ID"
    categoryId: [BaseFilterValue!]
    "Category name"
    categoryName: [BaseFilterValue!]
    "Collection Rating"
    collectionRating: [BaseFilterValue!]
    """

    Status of the collection. Valid values are: "unlisted",
    "under_moderation" (moderators/admins only), "discarded" (moderators/admins only).
    """
    collectionStatus: [BaseFilterValue!]
    "Nested filters."
    filter: [CollectionsFilter!]
    "Game domain name E.g. skyrim"
    gameDomain: [BaseFilterValue!]
    "Game ID"
    gameId: [BaseFilterValue!]
    "Game name E.g. Skyrim"
    gameName: [BaseFilterValue!]
    "Filter collections for specific game versions"
    gameVersion: [BaseFilterValue!]
    "Text search on name, summary and description, partial match."
    generalSearch: [CollectionGeneralSearchFilterValue!]
    "Only show collections that have a draft revision"
    hasDraftRevision: [BooleanFilterValue!]
    "Only show collections that have a published revision"
    hasPublishedRevision: [BooleanFilterValue!]
    "The mod unique identifier."
    modUid: [BaseFilterValue!]
    "Collection Name"
    name: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "The tag name, exact match."
    tag: [BaseFilterValue!]
    "User ID"
    userId: [BaseFilterValue!]
}

"Filter fields specific to the comments search query."
input CommentsSearchFilter {
    "Nested filters."
    filter: [CommentsSearchFilter!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "Full text search query."
    query: [BaseFilterValue!]
    "The ID of the comment thread to search within."
    threadId: [BaseFilterValue!]
}

"Sort fields specific to the comments search query."
input CommentsSearchSort {
    "Sort by most relevant first."
    relevance: BaseSortValue
}

"Defines a Mod request using Game Domain and Mod ID"
input CompositeDomainWithIdInput {
    "Game domain"
    gameDomain: String!
    "Mod ID"
    modId: Int!
}

"Defines a Mod request using Game ID and Mod ID"
input CompositeIdInput {
    "Game ID"
    gameId: Int!
    "Mod ID"
    modId: Int!
}

"A float value"
input FloatFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Float Value"
    value: Float!
}

input GameNameFieldFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Value"
    value: String!
}

"Facet fields specific to the games query."
input GamesFacet {
    "Facet on game genre."
    genre: [String!]
    "Facet on collections."
    hasCollections: [String!]
    "Facet on Vortex support."
    supportsVortex: [String!]
}

"Filter for a list of Games"
input GamesSearchFilter {
    "Nested filters."
    filter: [GamesSearchFilter!]
    "Game name suitable for use with op:wildcard, but not op:matches. Punctuation matched."
    name: [GameNameFieldFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
}

"Sort for a list of Games"
input GamesSearchSort {
    "Date approved."
    approved: BaseSortValue
    "Number of collections."
    collections: BaseSortValue
    "Number of downloads."
    downloads: BaseSortValue
    "Number of mods."
    mods: BaseSortValue
    "Game name."
    name: BaseSortValue
    "Filter query relevance."
    relevance: BaseSortValue
}

"An integer value"
input IntFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Integer Value"
    value: Int!
}

"Facet fields specific to the media query."
input MediaFacet {
    "Facet on category."
    category: [String!]
    "Facet on game ID."
    gameId: [String!]
    "Facet on media type."
    type: [String!]
}

input MediaGeneralSearchFilterValue {
    "Comparison operator for value."
    op: FilterComparisonOperator
    "Value"
    value: String!
}

"Filter fields specific to the legacy media search query."
input MediaSearchFilter {
    "Filter media by adult content"
    adultContent: [BooleanFilterValue!]
    "Date created, in unix timestamp"
    createdAt: [BaseFilterValue!]
    "Nested filters."
    filter: [MediaSearchFilter!]
    "Filter media by Game ID"
    gameId: [BaseFilterValue!]
    "Filter media by Game name"
    gameName: [BaseFilterValue!]
    "Text search on title and description, partial match."
    generalSearch: [MediaGeneralSearchFilterValue!]
    """

    Media status. Valid values are "published", "under_moderation" (moderators/admins only),
    "hidden" (for images moderator/admin only)
    """
    mediaStatus: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "Filter media by ID of the uploader"
    owner: [BaseFilterValue!]
    "Type of media item (\"image\", \"supporter_image\" or \"video\")"
    type: [BaseFilterValue!]
}

"Sort fields specific to the media query."
input MediaSearchSort {
    "Sort for 'new'."
    createdAt: BaseSortValue
    "Sort for 'surprise'."
    random: RandomSortValue
    "Sort for 'trending'."
    rating: BaseSortValue
    "Sort for 'popular'."
    views: BaseSortValue
}

"A moderation restriction"
input ModerationRestrictionInput {
    "Game ID"
    gameId: ID
    "Mod ID"
    modId: ID
    "Reason"
    restriction: ModerationRestrictions!
    "Timeframe in days"
    timeframe: Int!
}

"Facet fields specific to the mods query."
input ModsFacet {
    "Facet on adult."
    adult: [String!]
    "Facet on category."
    categoryName: [String!]
    "Facet on game domain name."
    gameDomainName: [String!]
    "Facet on game id."
    gameId: [String!]
    "Facet on game name."
    gameName: [String!]
    "Facet on language."
    languageName: [String!]
    "Facet on status."
    status: [String!]
    "Facet on tag."
    tag: [String!]
}

"Filter fields specific to a Mods query"
input ModsFilter {
    "Filter mods by adult content"
    adult: [BooleanFilterValue!] @deprecated(reason: "Deprecated in favour of `adult_content`.")
    "Filter mods by adult content"
    adultContent: [BooleanFilterValue!]
    "The name of the author"
    author: [BaseFilterValue!]
    "The mod category"
    categoryName: [BaseFilterValue!]
    "Date created, in unix timestamp"
    createdAt: [BaseFilterValue!]
    "The description of the mod"
    description: [BaseFilterValueEqualsMatches!]
    "Filter mods by download count"
    downloads: [IntFilterValue!]
    "Filter mods by endorsement count"
    endorsements: [IntFilterValue!]
    "Filter mods by file size"
    fileSize: [IntFilterValue!]
    "Nested filters."
    filter: [ModsFilter!]
    "Filter mods by Game domain name"
    gameDomainName: [BaseFilterValue!]
    "Filter mods by Game ID"
    gameId: [BaseFilterValue!]
    "The name of the game this mod is for"
    gameName: [BaseFilterValue!]
    "Filter mods by whether they have been updated since they were created"
    hasUpdated: [BooleanFilterValue!]
    "The language of the mod"
    languageName: [BaseFilterValue!]
    "Mod name suitable for use with op:wildcard, but not op:matches. Punctuation matched."
    name: [BaseFilterValueEqualsWildcard!]
    "Stemmed name, suitable for token matching (op:wildcard and op:matches). Punctuation not matched."
    nameStemmed: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
    "Filter mods by image, as returned by pictureUrl and thumbnailUrl."
    primaryImage: [BaseFilterValue!]
    "The mod status"
    status: [BaseFilterValue!]
    "Filter mods by whether they support Vortex"
    supportsVortex: [BooleanFilterValue!]
    "The tag name, exact match."
    tag: [BaseFilterValue!]
    "Date updated, in unix timestamp"
    updatedAt: [BaseFilterValue!]
    "The name of the uploader"
    uploader: [BaseFilterValue!]
    "Filter mods by uploader id"
    uploaderId: [BaseFilterValue!]
}

"Sort fields specific to a Mods query."
input ModsSort {
    "Date created."
    createdAt: BaseSortValue
    "Number of times downloaded."
    downloads: BaseSortValue
    "Number of times endorsed."
    endorsements: BaseSortValue
    "Date of last comment."
    lastComment: BaseSortValue
    "Mod name."
    name: BaseSortValue
    "Random mods."
    random: RandomSortValue
    "Filter query relevance, works best with non wildcard queries."
    relevance: BaseSortValue
    "Mod file size."
    size: BaseSortValue
    "Number of unique downloads."
    uniqueDownloads: BaseSortValue
    "Date updated."
    updatedAt: BaseSortValue
}

input RandomSortValue {
    "If passed, randomness will be deterministic"
    seed: Int
}

"Defines a Image Update request object"
input UpdateImageInput {
    "Alternative text"
    altText: String
    "Image ID"
    id: ID!
    "Image title"
    title: String
}

"Defines a Image Upload request object"
input UploadImageInput {
    "Alternative text of the image"
    altText: String
    "Image content type"
    contentType: String!
    "Image UUID"
    id: ID!
    "Image title"
    title: String
}

"Defines a Video Upload request object"
input UploadVideoInput {
    "Video URL"
    url: String!
}

"Filter fields specific to a Users query"
input UsersSearchFilter {
    "Nested filters."
    filter: [UsersSearchFilter!]
    "Username."
    nameExact: [BaseFilterValueEqualsMatches!]
    "Username."
    nameWildcard: [BaseFilterValue!]
    "Logical operator for clauses."
    op: FilterLogicalOperator
}

"Sort fields specific to a Users query."
input UsersSearchSort {
    "username"
    name: BaseSortValue
    "Filter query relevance, works best with non wildcard queries."
    relevance: BaseSortValue
}
