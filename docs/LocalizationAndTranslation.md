# Localization and Translation in the Nexus App

For more details, see [0007: Localization and Internationalisation](./decisions/backend/0007-localization-and-internationalisation.md).

In the Nexus App we use the industry standard `Resource` files for porting the App to different languages and cultures.

This involves creating a relevant `.resx` file in every project for the base language, and additional `.resx` files for any additional language you want to support.

Working with these files requires a supported IDE such as Rider or Visual Studio

### Live translation updates
While the current translations are implemented to support live update after a user changes the app language, this might not remain the case in the future.
The app will likely ask the user to restart the app to apply the change, which will take care of updating all the strings, making live update of localizable strings superfluous.

If ensuring live update proves hard to sustain in the future, a discussion can be had to revert to static references.

## Creating a New Language File

- Create a folder called `Resources`, if it does not already exist.
- Create a Resource file (`Add` -> `Resources`), name it `Language.resx`.

```
Resources/Language.resx
```

Doubleclicking this file in a supported IDE will bring you to the `Resource Editor`, which will allow you to edit the resources file.

### Additional Steps

For elements which may be referenced from the UI (Avalonia), an additional step is required.

When you create a Resource file from Within Rider, it will be set to `internal` by default. This is okay for code, but is not okay for XAML; as XAML needs those elements public.

To make these elements public, open the project's `.csproj` file; find the `.resx` file and change `ResXFileCodeGenerator` to `PublicResXFileCodeGenerator` such that you will see:

```
<EmbeddedResource Update="Resources\Language.resx">
    <Generator>PublicResXFileCodeGenerator</Generator>
    <LastGenOutput>Language.Designer.cs</LastGenOutput>
</EmbeddedResource>
```

You will then need to perform an action that would trigger a rebuild of `Language.Designer.cs`. This could be temporarily adding or renaming a key. These files are (unfortunately), not autogenerated as part of MSBuild.

## Adding a new Language

This should be supported as a button in your IDE (in Rider it is top left of 'Localization Manager', above the project listing).

If it is not natively supported, create a resource file using the naming convention:

```
Language.{culture}.resx
```

Manually. For example `Language.de.resx`. Both shorthands e.g. `de` (German) and full localized cultures e.g. `de-de` (German, Germany) are supported.

## Using Localized Strings

### Reference Text from C#

#### Basic Referencing

The items are exposed as static fields of the `Language` class; i.e.

```csharp
Language.MyGames
```

If you are in a context where the language cannot be dynamically changed (for example: in a dialog box that must be closed before the user can change the language again), using the static property is sufficient.


#### Formatted Text

In some cases, you might have to use `string.Format` to inject parameters into the text:

```
// Language.Hello is "Hello {0}"
string.Format(Language.Hello, user)
```

#### Updating Strings Dynamically

If you have a string in C# which is long lived, and will be live when the language is changed; it must be updated dynamically.

For this purpose, the `LocalizedStringUpdater` class is provided; it is used like this:

```csharp
_localizable = new LocalizedStringUpdater(() => ReactiveField = Language.MyGames);
```

To give an example:

```csharp
public class SomeViewModel : AViewModel<ISomeViewModel>, ISomeViewModel, IDisposable
{
    [Reactive]
    public string Name { get; set; } = "";

    private readonly LocalizedStringUpdater _nameUpdater;

    public SomeViewModel(Func<string> getName)
    {
        _nameUpdater = new LocalizedStringUpdater(() => Name = getName());
    }

    // Note: Multi-dispose guard not needed; LocalizedStringUpdater.Dispose by contract only unsubscribes from an event.
    public void Dispose() => _nameUpdater.Dispose();
}
```

When you call `new LocalizedStringUpdater` and every time the language is changed
through the use [Localizer.Instance.LoadLanguage](#switching-a-language), the callback given in the `LocalizedStringUpdater`
will be executed.

As for the `[Reactive]` fields, the autogenerated `INotifyPropertyChanged` handlers will always
do a comparison on the string in the setter. So if a string remains unchanged, no UI redraw will occur
for the affected element as `PropertyChanged` will not fire.

!!! note "The API is specifically designed like this to ensure compile time safety."

!!! danger "`LocalizedStringUpdater` must be properly disposed when no longer in use. Due to nature of .NET events, lack of proper disposal will lead to memory leak as the class subscribes to `Localizer` which has singleton lifetime."

##### Use within Reactive Code

When possible, use the `WhenActivated` ReactiveUI method; alongside `DisposeWith`. This will ensure that `LocalizedStringUpdater(s)` and structures which use them will be disposed safely.

```csharp
this.WhenActivated(disposable =>
{
    var items = new ILeftMenuItemViewModel[]
    {
        new IconViewModel(() => Language.Newsfeed) { ... }.DisposeWith(disposable),
        new IconViewModel(() => Language.MyGames) { ... }.DisposeWith(disposable),
        new IconViewModel(() => Language.BrowseGames) { ... }.DisposeWith(disposable)
    };
});
```
#### Updating Strings in Avalonia Objects from c#
In some cases the code behind directly sets properties of avalonia controls, for example:

```csharp
LoadoutColumn.Name => new TextBlock
{
    Text = "Name"
},
```

In these cases, you can use the static `Localizer.CreateAvaloniaBinding(Func<string>)` method to create a binding that will update when the language is changed.
For example:

```csharp
LoadoutColumn.Name => new TextBlock
{
    [!TextBlock.TextProperty] = Localizer.CreateAvaloniaBinding(() => Language.Helpers_GenerateHeader_NAME)
},
```
You should pass a function to `CreateAvaloniaBidning()` that returns the localized string you want to use.
The binding will take care of calling the function again when the language is changed, getting the new localized version.

### Reference from XAML

Use the custom `LocalizedExtension` markup extension to reference a localizable string.

```xaml
<TextBlock Text="{localization:Localized HelloWorld}"/>
```

If formatting is required, please do so in the code behind for the element to be consistent with the existing Reactive based code.

### Overriding the Language at Boot Time

You can change the locale in `AppConfig.json` file.
This file is in the `NexusMods.App` project at time of writing and is copied to build directory.

### Switching a Language

Language can be switched at runtime with the following code:

```
Localizer.Instance.LoadLanguage(new CultureInfo(/* locale */));
```

We run this code at startup in `OnFrameworkInitializationCompleted` to set the language at startup.
