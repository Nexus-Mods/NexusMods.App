# Localization and Translation in the Nexus App

For more details, see [0007: Localization and Internationalisation](./decisions/backend/0007-localization-and-internationalisation.md).

In the Nexus App we use the industry standard `Resource` files for porting the App to different languages and cultures.

This involves creating a relevant `.resx` file in every project for the base language, and additional `.resx` files for any additional language you want to support.

Working with these files requires a supported IDE such as Rider or Visual Studio

## Creating a New Language File

- Create a folder called `Resources`, if it does not already exist.
- Create a Resource file (`Add` -> `Resources`), name it `Language.resx`.

```
Resources/Language.resx
```

Doubleclicking this file in a supported IDE will bring you to the `Resource Editor`, which will allow you to edit the resources file.

### Additional Steps

For elements which may be referenced from the UI (Avalonia), an additional step is required.

When you create a Resource file from Within Rider, it will be set to `internal` by default. This is okay for code, but is not okay for XAML; as XAML needs those elements public.

To make these elements public, open the project's `.csproj` file; find the `.resx` file and change `ResXFileCodeGenerator` to `PublicResXFileCodeGenerator` such that you will see:

```
<EmbeddedResource Update="Resources\Language.resx">
    <Generator>PublicResXFileCodeGenerator</Generator>
    <LastGenOutput>Language.Designer.cs</LastGenOutput>
</EmbeddedResource>
```

You will then need to perform an action that would trigger a rebuild of `Language.Designer.cs`. This could be temporarily adding or renaming a key. These files are (unfortunately), not autogenerated as part of MSBuild.

## Adding a new Language

This should be supported as a button in your IDE (in Rider it is top left of 'Localization Manager', above the project listing).

If it is not natively supported, create a resource file using the naming convention:

```
Language.{culture}.resx
```

Manually. For example `Language.de.resx`. Both shorthands e.g. `de` (German) and full localized cultures e.g. `de-de` (German, Germany) are supported.

## Using Localized Strings

### Reference Text from C#

#### Basic Referencing

The items are exposed as static fields of the `Language` class; i.e.

```csharp
Language.MyGames
```

If you are in a context where the language cannot be dynamically changed (for example: in a dialog box that must be closed before the user can change the language again), using the static property is sufficient.


#### Formatted Text

In some cases, you might have to use `string.Format` to inject parameters into the text:

```
// Language.Hello is "Hello {0}"
string.Format(Language.Hello, user)
```

#### Updating Strings Dynamically

If you have a string in C# which is long lived, and will be live when the language is changed; it must be updated dynamically.

For this purpose, the `LocalizedStringUpdater` class is provided; it is used like this:

```csharp
_localizable = new LocalizedStringUpdater(() => ReactiveField = Language.MyGames);
```

To give an example:

```csharp
public class SomeViewModel : AViewModel<ISomeViewModel>, ISomeViewModel, IDisposable
{
    [Reactive]
    public string Name { get; set; } = "";

    private readonly LocalizedStringUpdater _nameUpdater;

    public SomeViewModel(Func<string> getName)
    {
        _nameUpdater = new LocalizedStringUpdater(() => Name = getName());
    }

    // Note: Multi-dispose guard not needed; LocalizedStringUpdater.Dispose by contract only unsubscribes from an event.
    public void Dispose() => _nameUpdater.Dispose();
}
```

When you call `new LocalizedStringUpdater` and every time the language is changed
through the use [Localizer.Instance.LoadLanguage](#switching-a-language), the callback given in the `LocalizedStringUpdater`
will be executed.

As for the `[Reactive]` fields, the autogenerated `INotifyPropertyChanged` handlers will always
do a comparison on the string in the setter. So if a string remains unchanged, no UI redraw will occur
for the affected element as `PropertyChanged` will not fire.

!!! note "The API is specifically designed like this to ensure compile time safety."

!!! danger "`LocalizedStringUpdater` must be properly disposed when no longer in use. Due to nature of .NET events, lack of proper disposal will lead to memory leak as the class subscribes to `Localizer` which has singleton lifetime."

##### Use within Reactive Code

When possible, use the `WhenActivated` ReactiveUI method; alongside `DisposeWith`. This will ensure that `LocalizedStringUpdater(s)` and structures which use them will be disposed safely.

```csharp
this.WhenActivated(disposable =>
{
    var items = new ILeftMenuItemViewModel[]
    {
        new IconViewModel(() => Language.Newsfeed) { ... }.DisposeWith(disposable),
        new IconViewModel(() => Language.MyGames) { ... }.DisposeWith(disposable),
        new IconViewModel(() => Language.BrowseGames) { ... }.DisposeWith(disposable)
    };
});
```
#### Updating Strings in Avalonia Objects from c#
In some cases the code behind directly sets properties of avalonia controls, for example:

```csharp
LoadoutColumn.Name => new TextBlock
{
    Text = "Name"
},
```

In these cases, you can use the static `Localizer.CreateAvaloniaBinding(Func<string>)` method to create a binding that will update when the language is changed.
For example:

```csharp
LoadoutColumn.Name => new TextBlock
{
    [!TextBlock.TextProperty] = Localizer.CreateAvaloniaBinding(() => Language.Helpers_GenerateHeader_NAME)
},
```
You should pass a function to `CreateAvaloniaBidning()` that returns the localized string you want to use.
The binding will take care of calling the function again when the language is changed, getting the new localized version.

### Reference from XAML

Use the custom `LocalizedExtension` markup extension to reference a localizable string.

```xaml
<TextBlock Text="{localization:Localized HelloWorld}"/>
```

If formatting is required, please do so in the code behind for the element to be consistent with the existing Reactive based code.

### Overriding the Language at Boot Time

You can change the locale in `AppConfig.json` file.
This file is in the `NexusMods.App` project at time of writing and is copied to build directory.

### Switching a Language

Language can be switched at runtime with the following code:

```
Localizer.Instance.LoadLanguage(new CultureInfo(/* locale */));
```

We run this code at startup in `OnFrameworkInitializationCompleted` to set the language at startup.
